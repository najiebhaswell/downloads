root@vpp-clixon /> show yang
module simple-interface {
   yang-version 1.1;
   namespace http://example.com/simple-interface;
   prefix si;
   organization "Contoh YANG Interface";
   contact dev@example.com;
   description "Contoh YANG model sederhana untuk interface jaringan";
   revision 2024-06-05 {
      description "Versi awal";
   }
   container interfaces {
      description "Daftar semua interface jaringan";
      list interface {
         key name;
         description "Satu entry interface";
         leaf name {
            type string;
            description "Nama interface (misal: GigabitEthernet0/1)";
         }
         leaf description {
            type string;
            description "Deskripsi interface";
         }
         leaf type {
            type enumeration {
               enum ethernet {
                  description Ethernet;
               }
               enum loopback {
                  description Loopback;
               }
               enum vpp {
                  description "VPP virtual interface";
               }
            }
            description "Tipe interface";
         }
         leaf enabled {
            type boolean;
            default true;
            description "Enable/disable interface";
         }
         leaf mtu {
            type uint16;
            description "MTU interface";
         }
         container ipv4 {
            description "Konfigurasi IPv4";
            leaf address {
               type string;
               description "Alamat IPv4 (misal: 192.168.1.1/24)";
            }
         }
         container ipv6 {
            description "Konfigurasi IPv6";
            leaf address {
               type string;
               description "Alamat IPv6 (misal: 2001:db8::1/64)";
            }
         }
         container state {
            config false;
            description "State data yang diisi otomatis dari backend eksternal";
            leaf link-up {
               type boolean;
               description "Status link (up/down)";
            }
            leaf admin-up {
               type boolean;
               description "Status admin up/down";
            }
            leaf oper-status {
               type string;
               description "Status operasional";
            }
         }
      }
   }
}
module clixon-lib {
   yang-version 1.1;
   namespace http://clicon.org/lib;
   prefix cl;
   import ietf-yang-types {
      prefix yang;
   }
   import ietf-netconf-monitoring {
      prefix ncm;
   }
   import ietf-yang-metadata {
      prefix md;
   }
   organization "Clicon / Clixon";
   contact "Olof Hagsand <olof@hagsand.se>";
   description "***** BEGIN LICENSE BLOCK *****
       Copyright (C) 2009-2019 Olof Hagsand
       Copyright (C) 2020-2022 Olof Hagsand and Rubicon Communications, LLC(Netgate)

       This file is part of CLIXON

       Licensed under the Apache License, Version 2.0 (the "License");
       you may not use this file except in compliance with the License.
       You may obtain a copy of the License at
            http://www.apache.org/licenses/LICENSE-2.0
       Unless required by applicable law or agreed to in writing, software
       distributed under the License is distributed on an "AS IS" BASIS,
       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
       See the License for the specific language governing permissions and
       limitations under the License.

       Alternatively, the contents of this file may be used under the terms of
       the GNU General Public License Version 3 or later (the "GPL"),
       in which case the provisions of the GPL are applicable instead
       of those above. If you wish to allow use of your version of this file only
       under the terms of the GPL, and not to allow others to
       use your version of this file under the terms of Apache License version 2,
       indicate your decision by deleting the provisions above and replace them with
       the notice and other provisions required by the GPL. If you do not delete
       the provisions above, a recipient may use your version of this file under
       the terms of any one of the Apache License version 2 or the GPL.

       ***** END LICENSE BLOCK *****

       Clixon Netconf extensions for communication between clients and backend.
       This scheme adds:
       - Added values of RFC6022 transport identityref
       - RPCs for debug, stats and process-control
       - Informal description of attributes

       Clixon also extends NETCONF for internal use with some internal attributes. These
       are not visible for external usage bit belongs to the namespace of this YANG.
       The internal attributes are:
       - content (also RESTCONF)
       - depth   (also RESTCONF)
       - username
       - autocommit
       - copystartup
       - transport (see RFC6022)
       - source-host (see RFC6022)
       - objectcreate
       - objectexisted
       - link # For split multiple XML files
      ";
   revision 2024-11-01 {
      description "Added: system-only-config extension
             Released in Clixon 7.3";
   }
   revision 2024-04-01 {
      description "Added: debug bits type
             Added: xmldb-split extension
             Added: Default format
             Released in Clixon 7.1";
   }
   revision 2024-01-01 {
      description "Removed container creators from 6.5
             Released in 7.0";
   }
   revision 2023-11-01 {
      description "Added ignore-compare extension
             Added creator meta configuration
             Removed obsolete extension autocli-op
             Released in 6.5.0";
   }
   revision 2023-05-01 {
      description "Restructured and extended stats rpc to schema mountpoints
             Moved datastore-format typedef from clixon-config
            ";
   }
   revision 2023-03-01 {
      description "Added creator meta-object";
   }
   revision 2022-12-01 {
      description "Added values of RFC6022 transport identityref
             Added description of internal netconf attributes";
   }
   revision 2021-12-05 {
      description "Obsoleted: extension autocli-op";
   }
   revision 2021-11-11 {
      description "Changed: RPC stats extended with YANG stats";
   }
   revision 2021-03-08 {
      description "Changed: RPC process-control output to choice dependent on operation";
   }
   revision 2020-12-30 {
      description "Changed: RPC process-control output parameter status to pid";
   }
   revision 2020-12-08 {
      description "Added: autocli-op extension.
                    rpc process-control for process/daemon management
             Released in clixon 4.9";
   }
   revision 2020-04-23 {
      description "Added: stats RPC for clixon XML and memory statistics.
             Added: restart-plugin RPC for restarting individual plugins without restarting backend.";
   }
   revision 2019-08-13 {
      description "No changes (reverted change)";
   }
   revision 2019-06-05 {
      description "ping rpc added for liveness";
   }
   revision 2019-01-02 {
      description "Released in Clixon 3.9";
   }
   typedef service-operation {
      type enumeration {
         enum start {
            description "Start if not already running";
         }
         enum stop {
            description "Stop if running";
         }
         enum restart {
            description "Stop if running, then start";
         }
         enum status {
            description "Check status";
         }
      }
      description "Common operations that can be performed on a service";
   }
   typedef datastore_format {
      description "Datastore format (only xml and json implemented in actual data.";
      type enumeration {
         enum xml {
            description "Save and load xmldb as XML
                 More specifically, such a file looks like: <config>...</config> provided
                 DATASTORE_TOP_SYMBOL is 'config'";
         }
         enum json {
            description "Save and load xmldb as JSON";
         }
         enum text {
            description "'Curly' C-like text format";
         }
         enum cli {
            description "CLI format";
         }
         enum default {
            description "Default format";
         }
      }
   }
   typedef clixon_debug_t {
      description "Debug flags.
             Flags are seperated into subject areas and detail
             Can also be given directly as -D <flag> to clixon commands
             Note there are also constants in the code that need to be in sync with these values";
      type bits {
         bit default {
            description "Default logs";
            position 0;
         }
         bit msg {
            description "In/out messages";
            position 1;
         }
         bit init {
            description Initialization;
            position 2;
         }
         bit xml {
            description "XML processing";
            position 3;
         }
         bit xpath {
            description "XPath processing";
            position 4;
         }
         bit yang {
            description "YANG processing";
            position 5;
         }
         bit backend {
            description Backend-specific;
            position 6;
         }
         bit cli {
            description "CLI frontend";
            position 7;
         }
         bit netconf {
            description "NETCONF frontend";
            position 8;
         }
         bit restconf {
            description "RESTCONF frontend";
            position 9;
         }
         bit snmp {
            description "SNMP frontend";
            position 10;
         }
         bit nacm {
            description "NACM processing";
            position 11;
         }
         bit proc {
            description "Process handling";
            position 12;
         }
         bit datastore {
            description "Datastore xmldb management";
            position 13;
         }
         bit event {
            description "Event processing";
            position 14;
         }
         bit rpc {
            description "RPC handling";
            position 15;
         }
         bit stream {
            description "Notification streams";
            position 16;
         }
         bit parse {
            description "Parser: XML,YANG, etc";
            position 17;
         }
         bit app {
            description "External applications";
            position 20;
         }
         bit app2 {
            description "External application";
            position 21;
         }
         bit app3 {
            description "External application 2";
            position 22;
         }
         bit detail {
            description "Details: traces, parse trees, etc";
            position 24;
         }
         bit detail2 {
            description "Extra details";
            position 25;
         }
         bit detail3 {
            description "Probably more detail than you want";
            position 26;
         }
      }
   }
   identity snmp {
      description SNMP;
      base ncm:transport;
   }
   identity netconf {
      description "Just NETCONF without specific underlying transport,
             Clixon uses stdio for its netconf client and therefore does not know whether it is
             invoked in a script, by a NETCONF/SSH subsystem, etc";
      base ncm:transport;
   }
   identity restconf {
      description "RESTCONF either as HTTP/1 or /2, TLS or not, reverse proxy (eg fcgi/nginx) or native";
      base ncm:transport;
   }
   identity cli {
      description "A CLI session";
      base ncm:transport;
   }
   extension ignore-compare {
      description "The object should be ignored when comparing device configs for equality.
             The object should never be added, modified, or deleted on target.
             Essentially a read-only object
             One example is auto-created objects by the controller, such as uid.";
   }
   extension xmldb-split {
      description "When split configuration stores are used, ie CLICON_XMLDB_MULTI is set,
             This extension marks where in the configuration tree, one file terminates
             and a new sub-file is written.
             A designer adds the 'xmldb-split' extension to a YANG node which should be split.
             For example, a split could be made at mountpoints.
             See also the 'link 'attribute.
             ";
   }
   extension system-only-config {
      description "This extension marks which fields in the configuration tree should not be
             saved to datastore and be removed from memory after commit.
             Instead, the application must provide a mechanism to save the system-only-config
             in the system:
               1. Mark system-only config data in YANG with this extension
               2. Write a commit callback for data write
               2. Write a system-only-config callback for data read
             Note that the XML with these values will be remove from the datastore. The remaining XML
             still needs to be valid XML wrt YANG.
             An example of an invalid marking would be a list key. Because if the list keys are
             removed, the remaining XML would no longer be valid wrt the YANG list";
   }
   md:annotation {
      type string;
      description "This annotation contains the name of a creator of an object.
             One application is the clixon controller where multiple services can
             create the same object. When such a service is deleted (or changed) one needs to keep
             track of which service created what.
             Limitations: only objects that are actually added or deleted.
             A sub-object will not be noted";
   }
   rpc debug {
      description "Set debug flags of backend.
             Note only numerical values";
      input {
         leaf level {
            type uint32;
         }
      }
   }
   rpc ping {
      description "Check aliveness of backend daemon.";
   }
   rpc stats {
      description "Clixon yang and datastore statistics.";
      input {
         leaf modules {
            description "If enabled include per-module statistics";
            type boolean;
            mandatory false;
         }
      }
      output {
         container global {
            description "Clixon global statistics.
                     These are global counters incremented by new() and decreased by free() calls.
                     This number is higher than the sum of all datastore/module residing objects, since
                     objects may be used for other purposes than datastore/modules";
            leaf xmlnr {
               description "Number of existing XML objects: number of residing xml/json objects
                         in the internal 'cxobj' representation.";
               type uint64;
            }
            leaf yangnr {
               description "Number of resident YANG objects. ";
               type uint64;
            }
         }
         container datastores {
            list datastore {
               description "Per datastore statistics for cxobj";
               key name;
               leaf name {
                  description "Name of datastore (eg running).";
                  type string;
               }
               leaf nr {
                  description "Number of XML objects. That is number of residing xml/json objects
                             in the internal 'cxobj' representation.";
                  type uint64;
               }
               leaf size {
                  description "Size in bytes of internal datastore cache of datastore tree.";
                  type uint64;
               }
            }
         }
         container module-sets {
            list module-set {
               description "Statistics per domain, eg top-level and mount-points";
               key name;
               leaf name {
                  description "Name of YANG domain.";
                  type string;
               }
               leaf nr {
                  description "Total number of YANG objects in set";
                  type uint64;
               }
               leaf size {
                  description "Total size in bytes of internal YANG object representation for module set";
                  type uint64;
               }
               list module {
                  description "Statistics per module (if modules set in input)";
                  key name;
                  leaf name {
                     description "Name of YANG module.";
                     type string;
                  }
                  leaf nr {
                     description "Number of YANG objects. That is number of residing YANG objects";
                     type uint64;
                  }
                  leaf size {
                     description "Size in bytes of internal YANG object representation.";
                     type uint64;
                  }
               }
            }
         }
      }
   }
   rpc restart-plugin {
      description "Restart specific backend plugins.";
      input {
         leaf-list plugin {
            description "Name of plugin to restart";
            type string;
         }
      }
   }
   rpc process-control {
      description "Control a specific process or daemon: start/stop, etc.
             This is for direct managing of a process by the backend.
             Alternatively one can manage a daemon via systemd, containerd, kubernetes, etc.";
      input {
         leaf name {
            description "Name of process";
            type string;
            mandatory true;
         }
         leaf operation {
            type service-operation;
            mandatory true;
            description "One of the strings 'start', 'stop', 'restart', or 'status'.";
         }
      }
      output {
         choice result {
            case status {
               description "Output from status rpc";
               leaf active {
                  description "True if process is running, false if not.
                             More specifically, there is a process-id and it exists (in Linux: kill(pid,0).
                             Note that this is actual state and status is administrative state,
                             which means that changing the administrative state, eg stopped->running
                             may not immediately switch active to true.";
                  type boolean;
               }
               leaf description {
                  type string;
                  description "Description of process. This is a static string";
               }
               leaf command {
                  type string;
                  description "Start command with arguments";
               }
               leaf status {
                  description "Administrative status (except on external kill where it enters stopped
                             directly from running):
                             stopped: pid=0,   No process running
                             running: pid set, Process started and believed to be running
                             exiting: pid set, Process is killed by parent but not waited for";
                  type string;
               }
               leaf starttime {
                  description "Time of starting process UTC";
                  type yang:date-and-time;
               }
               leaf pid {
                  description "Process-id of main running process (if active)";
                  type uint32;
               }
            }
            case other {
               description "Output from start/stop/restart rpc";
               leaf ok {
                  type empty;
               }
            }
         }
      }
   }
}
module ietf-yang-types {
   namespace urn:ietf:params:xml:ns:yang:ietf-yang-types;
   prefix yang;
   organization "IETF NETMOD (NETCONF Data Modeling Language) Working Group";
   contact "WG Web:   <http://tools.ietf.org/wg/netmod/>
       WG List:  <mailto:netmod@ietf.org>

       WG Chair: David Kessens
                 <mailto:david.kessens@nsn.com>

       WG Chair: Juergen Schoenwaelder
                 <mailto:j.schoenwaelder@jacobs-university.de>

       Editor:   Juergen Schoenwaelder
                 <mailto:j.schoenwaelder@jacobs-university.de>";
   description "This module contains a collection of generally useful derived
       YANG data types.

       Copyright (c) 2013 IETF Trust and the persons identified as
       authors of the code.  All rights reserved.

       Redistribution and use in source and binary forms, with or
       without modification, is permitted pursuant to, and subject
       to the license terms contained in, the Simplified BSD License
       set forth in Section 4.c of the IETF Trust's Legal Provisions
       Relating to IETF Documents
       (http://trustee.ietf.org/license-info).

       This version of this YANG module is part of RFC 6991; see
       the RFC itself for full legal notices.";
   revision 2013-07-15 {
      description "This revision adds the following new data types:
         - yang-identifier
         - hex-string
         - uuid
         - dotted-quad";
      reference "RFC 6991: Common YANG Data Types";
   }
   revision 2010-09-24 {
      description "Initial revision.";
      reference "RFC 6021: Common YANG Data Types";
   }
   typedef counter32 {
      type uint32;
      description "The counter32 type represents a non-negative integer
         that monotonically increases until it reaches a
         maximum value of 2^32-1 (4294967295 decimal), when it
         wraps around and starts increasing again from zero.

         Counters have no defined 'initial' value, and thus, a
         single value of a counter has (in general) no information
         content.  Discontinuities in the monotonically increasing
         value normally occur at re-initialization of the
         management system, and at other times as specified in the
         description of a schema node using this type.  If such
         other times can occur, for example, the creation of
         a schema node of type counter32 at times other than
         re-initialization, then a corresponding schema node
         should be defined, with an appropriate type, to indicate
         the last discontinuity.

         The counter32 type should not be used for configuration
         schema nodes.  A default statement SHOULD NOT be used in
         combination with the type counter32.

         In the value set and its semantics, this type is equivalent
         to the Counter32 type of the SMIv2.";
      reference "RFC 2578: Structure of Management Information Version 2
                   (SMIv2)";
   }
   typedef zero-based-counter32 {
      type yang:counter32;
      default 0;
      description "The zero-based-counter32 type represents a counter32
         that has the defined 'initial' value zero.

         A schema node of this type will be set to zero (0) on creation
         and will thereafter increase monotonically until it reaches
         a maximum value of 2^32-1 (4294967295 decimal), when it
         wraps around and starts increasing again from zero.

         Provided that an application discovers a new schema node
         of this type within the minimum time to wrap, it can use the
         'initial' value as a delta.  It is important for a management
         station to be aware of this minimum time and the actual time
         between polls, and to discard data if the actual time is too
         long or there is no defined minimum time.

         In the value set and its semantics, this type is equivalent
         to the ZeroBasedCounter32 textual convention of the SMIv2.";
      reference "RFC 4502: Remote Network Monitoring Management Information
                    Base Version 2";
   }
   typedef counter64 {
      type uint64;
      description "The counter64 type represents a non-negative integer
         that monotonically increases until it reaches a
         maximum value of 2^64-1 (18446744073709551615 decimal),
         when it wraps around and starts increasing again from zero.

         Counters have no defined 'initial' value, and thus, a
         single value of a counter has (in general) no information
         content.  Discontinuities in the monotonically increasing
         value normally occur at re-initialization of the
         management system, and at other times as specified in the
         description of a schema node using this type.  If such
         other times can occur, for example, the creation of
         a schema node of type counter64 at times other than
         re-initialization, then a corresponding schema node
         should be defined, with an appropriate type, to indicate
         the last discontinuity.

         The counter64 type should not be used for configuration
         schema nodes.  A default statement SHOULD NOT be used in
         combination with the type counter64.

         In the value set and its semantics, this type is equivalent
         to the Counter64 type of the SMIv2.";
      reference "RFC 2578: Structure of Management Information Version 2
                   (SMIv2)";
   }
   typedef zero-based-counter64 {
      type yang:counter64;
      default 0;
      description "The zero-based-counter64 type represents a counter64 that
         has the defined 'initial' value zero.




         A schema node of this type will be set to zero (0) on creation
         and will thereafter increase monotonically until it reaches
         a maximum value of 2^64-1 (18446744073709551615 decimal),
         when it wraps around and starts increasing again from zero.

         Provided that an application discovers a new schema node
         of this type within the minimum time to wrap, it can use the
         'initial' value as a delta.  It is important for a management
         station to be aware of this minimum time and the actual time
         between polls, and to discard data if the actual time is too
         long or there is no defined minimum time.

         In the value set and its semantics, this type is equivalent
         to the ZeroBasedCounter64 textual convention of the SMIv2.";
      reference "RFC 2856: Textual Conventions for Additional High Capacity
                   Data Types";
   }
   typedef gauge32 {
      type uint32;
      description "The gauge32 type represents a non-negative integer, which
         may increase or decrease, but shall never exceed a maximum
         value, nor fall below a minimum value.  The maximum value
         cannot be greater than 2^32-1 (4294967295 decimal), and
         the minimum value cannot be smaller than 0.  The value of
         a gauge32 has its maximum value whenever the information
         being modeled is greater than or equal to its maximum
         value, and has its minimum value whenever the information
         being modeled is smaller than or equal to its minimum value.
         If the information being modeled subsequently decreases
         below (increases above) the maximum (minimum) value, the
         gauge32 also decreases (increases).

         In the value set and its semantics, this type is equivalent
         to the Gauge32 type of the SMIv2.";
      reference "RFC 2578: Structure of Management Information Version 2
                   (SMIv2)";
   }
   typedef gauge64 {
      type uint64;
      description "The gauge64 type represents a non-negative integer, which
         may increase or decrease, but shall never exceed a maximum
         value, nor fall below a minimum value.  The maximum value
         cannot be greater than 2^64-1 (18446744073709551615), and
         the minimum value cannot be smaller than 0.  The value of
         a gauge64 has its maximum value whenever the information
         being modeled is greater than or equal to its maximum
         value, and has its minimum value whenever the information
         being modeled is smaller than or equal to its minimum value.
         If the information being modeled subsequently decreases
         below (increases above) the maximum (minimum) value, the
         gauge64 also decreases (increases).

         In the value set and its semantics, this type is equivalent
         to the CounterBasedGauge64 SMIv2 textual convention defined
         in RFC 2856";
      reference "RFC 2856: Textual Conventions for Additional High Capacity
                   Data Types";
   }
   typedef object-identifier {
      type string {
         pattern (([0-1](\.[1-3]?[0-9]))|(2\.(0|([1-9]\d*))))(\.(0|([1-9]\d*)))*;
      }
      description "The object-identifier type represents administratively
         assigned names in a registration-hierarchical-name tree.

         Values of this type are denoted as a sequence of numerical
         non-negative sub-identifier values.  Each sub-identifier
         value MUST NOT exceed 2^32-1 (4294967295).  Sub-identifiers
         are separated by single dots and without any intermediate
         whitespace.

         The ASN.1 standard restricts the value space of the first
         sub-identifier to 0, 1, or 2.  Furthermore, the value space
         of the second sub-identifier is restricted to the range
         0 to 39 if the first sub-identifier is 0 or 1.  Finally,
         the ASN.1 standard requires that an object identifier
         has always at least two sub-identifiers.  The pattern
         captures these restrictions.

         Although the number of sub-identifiers is not limited,
         module designers should realize that there may be
         implementations that stick with the SMIv2 limit of 128
         sub-identifiers.

         This type is a superset of the SMIv2 OBJECT IDENTIFIER type
         since it is not restricted to 128 sub-identifiers.  Hence,
         this type SHOULD NOT be used to represent the SMIv2 OBJECT
         IDENTIFIER type; the object-identifier-128 type SHOULD be
         used instead.";
      reference "ISO9834-1: Information technology -- Open Systems
         Interconnection -- Procedures for the operation of OSI
         Registration Authorities: General procedures and top
         arcs of the ASN.1 Object Identifier tree";
   }
   typedef object-identifier-128 {
      type object-identifier {
         pattern \d*(\.\d*){1,127};
      }
      description "This type represents object-identifiers restricted to 128
         sub-identifiers.

         In the value set and its semantics, this type is equivalent
         to the OBJECT IDENTIFIER type of the SMIv2.";
      reference "RFC 2578: Structure of Management Information Version 2
                   (SMIv2)";
   }
   typedef yang-identifier {
      type string {
         length 1..max;
         pattern [a-zA-Z_][a-zA-Z0-9\-_.]*;
         pattern .|..|[^xX].*|.[^mM].*|..[^lL].*;
      }
      description "A YANG identifier string as defined by the 'identifier'
          rule in Section 12 of RFC 6020.  An identifier must
          start with an alphabetic character or an underscore
          followed by an arbitrary sequence of alphabetic or
          numeric characters, underscores, hyphens, or dots.

          A YANG identifier MUST NOT start with any possible
          combination of the lowercase or uppercase character
          sequence 'xml'.";
      reference "RFC 6020: YANG - A Data Modeling Language for the Network
                    Configuration Protocol (NETCONF)";
   }
   typedef date-and-time {
      type string {
         pattern \d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?(Z|[\+\-]\d{2}:\d{2});
      }
      description "The date-and-time type is a profile of the ISO 8601
         standard for representation of dates and times using the
         Gregorian calendar.  The profile is defined by the
         date-time production in Section 5.6 of RFC 3339.

         The date-and-time type is compatible with the dateTime XML
         schema type with the following notable exceptions:

         (a) The date-and-time type does not allow negative years.

         (b) The date-and-time time-offset -00:00 indicates an unknown
             time zone (see RFC 3339) while -00:00 and +00:00 and Z
             all represent the same time zone in dateTime.

         (c) The canonical format (see below) of data-and-time values
             differs from the canonical format used by the dateTime XML
             schema type, which requires all times to be in UTC using
             the time-offset 'Z'.

         This type is not equivalent to the DateAndTime textual
         convention of the SMIv2 since RFC 3339 uses a different
         separator between full-date and full-time and provides
         higher resolution of time-secfrac.

         The canonical format for date-and-time values with a known time
         zone uses a numeric time zone offset that is calculated using
         the device's configured known offset to UTC time.  A change of
         the device's offset to UTC time will cause date-and-time values
         to change accordingly.  Such changes might happen periodically
         in case a server follows automatically daylight saving time
         (DST) time zone offset changes.  The canonical format for
         date-and-time values with an unknown time zone (usually
         referring to the notion of local time) uses the time-offset
         -00:00.";
      reference "RFC 3339: Date and Time on the Internet: Timestamps
         RFC 2579: Textual Conventions for SMIv2
         XSD-TYPES: XML Schema Part 2: Datatypes Second Edition";
   }
   typedef timeticks {
      type uint32;
      description "The timeticks type represents a non-negative integer that
         represents the time, modulo 2^32 (4294967296 decimal), in
         hundredths of a second between two epochs.  When a schema
         node is defined that uses this type, the description of
         the schema node identifies both of the reference epochs.

         In the value set and its semantics, this type is equivalent
         to the TimeTicks type of the SMIv2.";
      reference "RFC 2578: Structure of Management Information Version 2
                   (SMIv2)";
   }
   typedef timestamp {
      type yang:timeticks;
      description "The timestamp type represents the value of an associated
         timeticks schema node at which a specific occurrence
         happened.  The specific occurrence must be defined in the
         description of any schema node defined using this type.  When
         the specific occurrence occurred prior to the last time the
         associated timeticks attribute was zero, then the timestamp
         value is zero.  Note that this requires all timestamp values
         to be reset to zero when the value of the associated timeticks
         attribute reaches 497+ days and wraps around to zero.

         The associated timeticks schema node must be specified
         in the description of any schema node using this type.

         In the value set and its semantics, this type is equivalent
         to the TimeStamp textual convention of the SMIv2.";
      reference "RFC 2579: Textual Conventions for SMIv2";
   }
   typedef phys-address {
      type string {
         pattern ([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?;
      }
      description "Represents media- or physical-level addresses represented
         as a sequence octets, each octet represented by two hexadecimal
         numbers.  Octets are separated by colons.  The canonical
         representation uses lowercase characters.

         In the value set and its semantics, this type is equivalent
         to the PhysAddress textual convention of the SMIv2.";
      reference "RFC 2579: Textual Conventions for SMIv2";
   }
   typedef mac-address {
      type string {
         pattern [0-9a-fA-F]{2}(:[0-9a-fA-F]{2}){5};
      }
      description "The mac-address type represents an IEEE 802 MAC address.
         The canonical representation uses lowercase characters.

         In the value set and its semantics, this type is equivalent
         to the MacAddress textual convention of the SMIv2.";
      reference "IEEE 802: IEEE Standard for Local and Metropolitan Area
                   Networks: Overview and Architecture
         RFC 2579: Textual Conventions for SMIv2";
   }
   typedef xpath1.0 {
      type string;
      description "This type represents an XPATH 1.0 expression.

         When a schema node is defined that uses this type, the
         description of the schema node MUST specify the XPath
         context in which the XPath expression is evaluated.";
      reference "XPATH: XML Path Language (XPath) Version 1.0";
   }
   typedef hex-string {
      type string {
         pattern ([0-9a-fA-F]{2}(:[0-9a-fA-F]{2})*)?;
      }
      description "A hexadecimal string with octets represented as hex digits
         separated by colons.  The canonical representation uses
         lowercase characters.";
   }
   typedef uuid {
      type string {
         pattern [0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12};
      }
      description "A Universally Unique IDentifier in the string representation
         defined in RFC 4122.  The canonical representation uses
         lowercase characters.

         The following is an example of a UUID in string representation:
         f81d4fae-7dec-11d0-a765-00a0c91e6bf6
         ";
      reference "RFC 4122: A Universally Unique IDentifier (UUID) URN
                   Namespace";
   }
   typedef dotted-quad {
      type string {
         pattern (([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]);
      }
      description "An unsigned 32-bit number expressed in the dotted-quad
          notation, i.e., four octets written as decimal numbers
          and separated with the '.' (full stop) character.";
   }
}
module ietf-netconf-monitoring {
   namespace urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring;
   prefix ncm;
   import ietf-yang-types {
      prefix yang;
   }
   import ietf-inet-types {
      prefix inet;
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   <http://tools.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     WG Chair: Mehmet Ersue
               <mailto:mehmet.ersue@nsn.com>

     WG Chair: Bert Wijnen
               <mailto:bertietf@bwijnen.net>

     Editor:   Mark Scott
               <mailto:mark.scott@ericsson.com>

     Editor:   Martin Bjorklund
               <mailto:mbj@tail-f.com>";
   description "NETCONF Monitoring Module.
     All elements in this module are read-only.

     Copyright (c) 2010 IETF Trust and the persons identified as
     authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD
     License set forth in Section 4.c of the IETF Trust's
     Legal Provisions Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 6022; see
     the RFC itself for full legal notices.";
   revision 2010-10-04 {
      description "Initial revision.";
      reference "RFC 6022: YANG Module for NETCONF Monitoring";
   }
   typedef netconf-datastore-type {
      type enumeration {
         enum running;
         enum candidate;
         enum startup;
      }
      description "Enumeration of possible NETCONF datastore types.";
      reference "RFC 4741: NETCONF Configuration Protocol";
   }
   identity transport {
      description "Base identity for NETCONF transport types.";
   }
   identity netconf-ssh {
      base transport;
      description "NETCONF over Secure Shell (SSH).";
      reference "RFC 4742: Using the NETCONF Configuration Protocol
                 over Secure SHell (SSH)";
   }
   identity netconf-soap-over-beep {
      base transport;
      description "NETCONF over Simple Object Access Protocol (SOAP) over
       Blocks Extensible Exchange Protocol (BEEP).";
      reference "RFC 4743: Using NETCONF over the Simple Object
                 Access Protocol (SOAP)";
   }
   identity netconf-soap-over-https {
      base transport;
      description "NETCONF over Simple Object Access Protocol (SOAP)
      over Hypertext Transfer Protocol Secure (HTTPS).";
      reference "RFC 4743: Using NETCONF over the Simple Object
                 Access Protocol (SOAP)";
   }
   identity netconf-beep {
      base transport;
      description "NETCONF over Blocks Extensible Exchange Protocol (BEEP).";
      reference "RFC 4744: Using the NETCONF Protocol over the
                 Blocks Extensible Exchange Protocol (BEEP)";
   }
   identity netconf-tls {
      base transport;
      description "NETCONF over Transport Layer Security (TLS).";
      reference "RFC 5539: NETCONF over Transport Layer Security (TLS)";
   }
   identity schema-format {
      description "Base identity for data model schema languages.";
   }
   identity xsd {
      base schema-format;
      description "W3C XML Schema Definition.";
      reference "W3C REC REC-xmlschema-1-20041028:
         XML Schema Part 1: Structures";
   }
   identity yang {
      base schema-format;
      description "The YANG data modeling language for NETCONF.";
      reference "RFC 6020:  YANG - A Data Modeling Language for the
                  Network Configuration Protocol (NETCONF)";
   }
   identity yin {
      base schema-format;
      description "The YIN syntax for YANG.";
      reference "RFC 6020:  YANG - A Data Modeling Language for the
                  Network Configuration Protocol (NETCONF)";
   }
   identity rng {
      base schema-format;
      description "Regular Language for XML Next Generation (RELAX NG).";
      reference "ISO/IEC 19757-2:2008: RELAX NG";
   }
   identity rnc {
      base schema-format;
      description "Relax NG Compact Syntax";
      reference "ISO/IEC 19757-2:2008: RELAX NG";
   }
   grouping common-counters {
      description "Counters that exist both per session, and also globally,
       accumulated from all sessions.";
      leaf in-rpcs {
         type yang:zero-based-counter32;
         description "Number of correct <rpc> messages received.";
      }
      leaf in-bad-rpcs {
         type yang:zero-based-counter32;
         description "Number of messages received when an <rpc> message was expected,
         that were not correct <rpc> messages.  This includes XML parse
         errors and errors on the rpc layer.";
      }
      leaf out-rpc-errors {
         type yang:zero-based-counter32;
         description "Number of <rpc-reply> messages sent that contained an
         <rpc-error> element.";
      }
      leaf out-notifications {
         type yang:zero-based-counter32;
         description "Number of <notification> messages sent.";
      }
   }
   container netconf-state {
      config false;
      description "The netconf-state container is the root of the monitoring
       data model.";
      container capabilities {
         description "Contains the list of NETCONF capabilities supported by the
         server.";
         leaf-list capability {
            type inet:uri;
            description "List of NETCONF capabilities supported by the server.";
         }
      }
      container datastores {
         description "Contains the list of NETCONF configuration datastores.";
         list datastore {
            key name;
            description "List of NETCONF configuration datastores supported by
           the NETCONF server and related information.";
            leaf name {
               type netconf-datastore-type;
               description "Name of the datastore associated with this list entry.";
            }
            container locks {
               presence "This container is present only if the datastore
             is locked.";
               description "The NETCONF <lock> and <partial-lock> operations allow
             a client to lock specific resources in a datastore.  The
             NETCONF server will prevent changes to the locked
             resources by all sessions except the one that acquired
             the lock(s).

             Monitoring information is provided for each datastore
             entry including details such as the session that acquired
             the lock, the type of lock (global or partial) and the
             list of locked resources.  Multiple locks per datastore
             are supported.";
               grouping lock-info {
                  description "Lock related parameters, common to both global and
               partial locks.";
                  leaf locked-by-session {
                     type uint32;
                     mandatory true;
                     description "The session ID of the session that has locked
                 this resource.  Both a global lock and a partial
                 lock MUST contain the NETCONF session-id.

                 If the lock is held by a session that is not managed
                 by the NETCONF server (e.g., a CLI session), a session
                 id of 0 (zero) is reported.";
                     reference "RFC 4741: NETCONF Configuration Protocol";
                  }
                  leaf locked-time {
                     type yang:date-and-time;
                     mandatory true;
                     description "The date and time of when the resource was
                 locked.";
                  }
               }
               choice lock-type {
                  description "Indicates if a global lock or a set of partial locks
               are set.";
                  container global-lock {
                     description "Present if the global lock is set.";
                     uses lock-info;
                     leaf locked-by-session {
                        type uint32;
                        mandatory true;
                        description "The session ID of the session that has locked
                 this resource.  Both a global lock and a partial
                 lock MUST contain the NETCONF session-id.

                 If the lock is held by a session that is not managed
                 by the NETCONF server (e.g., a CLI session), a session
                 id of 0 (zero) is reported.";
                        reference "RFC 4741: NETCONF Configuration Protocol";
                     }
                     leaf locked-time {
                        type yang:date-and-time;
                        mandatory true;
                        description "The date and time of when the resource was
                 locked.";
                     }
                  }
                  list partial-lock {
                     key lock-id;
                     description "List of partial locks.";
                     reference "RFC 5717: Partial Lock Remote Procedure Call (RPC) for
                           NETCONF";
                     leaf lock-id {
                        type uint32;
                        description "This is the lock id returned in the <partial-lock>
                   response.";
                     }
                     uses lock-info;
                     leaf locked-by-session {
                        type uint32;
                        mandatory true;
                        description "The session ID of the session that has locked
                 this resource.  Both a global lock and a partial
                 lock MUST contain the NETCONF session-id.

                 If the lock is held by a session that is not managed
                 by the NETCONF server (e.g., a CLI session), a session
                 id of 0 (zero) is reported.";
                        reference "RFC 4741: NETCONF Configuration Protocol";
                     }
                     leaf locked-time {
                        type yang:date-and-time;
                        mandatory true;
                        description "The date and time of when the resource was
                 locked.";
                     }
                     leaf-list select {
                        type yang:xpath1.0;
                        min-elements 1;
                        description "The xpath expression that was used to request
                   the lock.  The select expression indicates the
                   original intended scope of the lock.";
                     }
                     leaf-list locked-node {
                        type instance-identifier;
                        description "The list of instance-identifiers (i.e., the
                   locked nodes).

                   The scope of the partial lock is defined by the list
                   of locked nodes.";
                     }
                  }
               }
            }
         }
      }
      container schemas {
         description "Contains the list of data model schemas supported by the
         server.";
         list schema {
            key "identifier version format";
            description "List of data model schemas supported by the server.";
            leaf identifier {
               type string;
               description "Identifier to uniquely reference the schema.  The
             identifier is used in the <get-schema> operation and may
             be used for other purposes such as file retrieval.

             For modeling languages that support or require a data
             model name (e.g., YANG module name) the identifier MUST
             match that name.  For YANG data models, the identifier is
             the name of the module or submodule.  In other cases, an
             identifier such as a filename MAY be used instead.";
            }
            leaf version {
               type string;
               description "Version of the schema supported.  Multiple versions MAY be
             supported simultaneously by a NETCONF server.  Each
             version MUST be reported individually in the schema list,
             i.e., with same identifier, possibly different location,
             but different version.

             For YANG data models, version is the value of the most
             recent YANG 'revision' statement in the module or
             submodule, or the empty string if no 'revision' statement
             is present.";
            }
            leaf format {
               type identityref {
                  base schema-format;
               }
               description "The data modeling language the schema is written
             in (currently xsd, yang, yin, rng, or rnc).

             For YANG data models, 'yang' format MUST be supported and
             'yin' format MAY also be provided.";
            }
            leaf namespace {
               type inet:uri;
               mandatory true;
               description "The XML namespace defined by the data model.

             For YANG data models, this is the module's namespace.
             If the list entry describes a submodule, this field
             contains the namespace of the module to which the
             submodule belongs.";
            }
            leaf-list location {
               type union {
                  type enumeration {
                     enum NETCONF;
                  }
                  type inet:uri;
               }
               description "One or more locations from which the schema can be
             retrieved.  This list SHOULD contain at least one
             entry per schema.

             A schema entry may be located on a remote file system
             (e.g., reference to file system for ftp retrieval) or
             retrieved directly from a server supporting the
             <get-schema> operation (denoted by the value 'NETCONF').";
            }
         }
      }
      container sessions {
         description "The sessions container includes session-specific data for
         NETCONF management sessions.  The session list MUST include
         all currently active NETCONF sessions.";
         list session {
            key session-id;
            description "All NETCONF sessions managed by the NETCONF server
           MUST be reported in this list.";
            leaf session-id {
               type uint32 {
                  range 1..max;
               }
               description "Unique identifier for the session.  This value is the
             NETCONF session identifier, as defined in RFC 4741.";
               reference "RFC 4741: NETCONF Configuration Protocol";
            }
            leaf transport {
               type identityref {
                  base transport;
               }
               mandatory true;
               description "Identifies the transport for each session, e.g.,
            'netconf-ssh', 'netconf-soap', etc.";
            }
            leaf username {
               type string;
               mandatory true;
               description "The username is the client identity that was authenticated
            by the NETCONF transport protocol.  The algorithm used to
            derive the username is NETCONF transport protocol specific
            and in addition specific to the authentication mechanism
            used by the NETCONF transport protocol.";
            }
            leaf source-host {
               type inet:host;
               description "Host identifier of the NETCONF client.  The value
             returned is implementation specific (e.g., hostname,
             IPv4 address, IPv6 address)";
            }
            leaf login-time {
               type yang:date-and-time;
               mandatory true;
               description "Time at the server at which the session was established.";
            }
            uses common-counters {
               description "Per-session counters.  Zero based with following reset
             behaviour:
               - at start of a session
               - when max value is reached";
            }
            leaf in-rpcs {
               type yang:zero-based-counter32;
               description "Number of correct <rpc> messages received.";
            }
            leaf in-bad-rpcs {
               type yang:zero-based-counter32;
               description "Number of messages received when an <rpc> message was expected,
         that were not correct <rpc> messages.  This includes XML parse
         errors and errors on the rpc layer.";
            }
            leaf out-rpc-errors {
               type yang:zero-based-counter32;
               description "Number of <rpc-reply> messages sent that contained an
         <rpc-error> element.";
            }
            leaf out-notifications {
               type yang:zero-based-counter32;
               description "Number of <notification> messages sent.";
            }
         }
      }
      container statistics {
         description "Statistical data pertaining to the NETCONF server.";
         leaf netconf-start-time {
            type yang:date-and-time;
            description "Date and time at which the management subsystem was
           started.";
         }
         leaf in-bad-hellos {
            type yang:zero-based-counter32;
            description "Number of sessions silently dropped because an
          invalid <hello> message was received.  This includes <hello>
          messages with a 'session-id' attribute, bad namespace, and
          bad capability declarations.";
         }
         leaf in-sessions {
            type yang:zero-based-counter32;
            description "Number of sessions started.  This counter is incremented
           when a <hello> message with a <session-id> is sent.

          'in-sessions' - 'in-bad-hellos' =
              'number of correctly started netconf sessions'";
         }
         leaf dropped-sessions {
            type yang:zero-based-counter32;
            description "Number of sessions that were abnormally terminated, e.g.,
           due to idle timeout or transport close.  This counter is not
           incremented when a session is properly closed by a
           <close-session> operation, or killed by a <kill-session>
           operation.";
         }
         uses common-counters {
            description "Global counters, accumulated from all sessions.
           Zero based with following reset behaviour:
             - re-initialization of NETCONF server
             - when max value is reached";
         }
         leaf in-rpcs {
            type yang:zero-based-counter32;
            description "Number of correct <rpc> messages received.";
         }
         leaf in-bad-rpcs {
            type yang:zero-based-counter32;
            description "Number of messages received when an <rpc> message was expected,
         that were not correct <rpc> messages.  This includes XML parse
         errors and errors on the rpc layer.";
         }
         leaf out-rpc-errors {
            type yang:zero-based-counter32;
            description "Number of <rpc-reply> messages sent that contained an
         <rpc-error> element.";
         }
         leaf out-notifications {
            type yang:zero-based-counter32;
            description "Number of <notification> messages sent.";
         }
      }
   }
   rpc get-schema {
      description "This operation is used to retrieve a schema from the
       NETCONF server.

       Positive Response:
         The NETCONF server returns the requested schema.

       Negative Response:
         If requested schema does not exist, the <error-tag> is
         'invalid-value'.

         If more than one schema matches the requested parameters, the
         <error-tag> is 'operation-failed', and <error-app-tag> is
         'data-not-unique'.";
      input {
         leaf identifier {
            type string;
            mandatory true;
            description "Identifier for the schema list entry.";
         }
         leaf version {
            type string;
            description "Version of the schema requested.  If this parameter is not
           present, and more than one version of the schema exists on
           the server, a 'data-not-unique' error is returned, as
           described above.";
         }
         leaf format {
            type identityref {
               base schema-format;
            }
            description "The data modeling language of the schema.  If this
            parameter is not present, and more than one formats of
            the schema exists on the server, a 'data-not-unique' error
            is returned, as described above.";
         }
      }
      output {
         anyxml data {
            description "Contains the schema content.";
         }
      }
   }
}
module ietf-inet-types {
   namespace urn:ietf:params:xml:ns:yang:ietf-inet-types;
   prefix inet;
   organization "IETF Network Modeling (NETMOD) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netmod/>
    WG List:  <mailto:netmod@ietf.org>

    Editor:   Juergen Schoenwaelder
              <mailto:j.schoenwaelder@jacobs-university.de>";
   description "This module contains a collection of generally useful derived
    YANG data types for Internet addresses and related things.

    The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
    NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
    'MAY', and 'OPTIONAL' in this document are to be interpreted as
    described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
    they appear in all capitals, as shown here.

    Copyright (c) 2021 IETF Trust and the persons identified as
    authors of the code.  All rights reserved.

    Redistribution and use in source and binary forms, with or
    without modification, is permitted pursuant to, and subject
    to the license terms contained in, the Simplified BSD License
    set forth in Section 4.c of the IETF Trust's Legal Provisions
    Relating to IETF Documents
    (http://trustee.ietf.org/license-info).

    This version of this YANG module is part of RFC XXXX;
    see the RFC itself for full legal notices.";
   revision 2021-02-22 {
      description "This revision adds the following new data types:
      - inet:ip-address-and-prefix
      - inet:ipv4-address-and-prefix
      - inet:ipv6-address-and-prefix
      - inet:host-name
      - inet:email-address
      The inet:host union was changed to use inet:host-name instead
      of inet:domain-name.";
      reference "RFC XXXX: Common YANG Data Types";
   }
   revision 2013-07-15 {
      description "This revision adds the following new data types:
      - inet:ip-address-no-zone
      - inet:ipv4-address-no-zone
      - inet:ipv6-address-no-zone";
      reference "RFC 6991: Common YANG Data Types";
   }
   revision 2010-09-24 {
      description "Initial revision.";
      reference "RFC 6021: Common YANG Data Types";
   }
   typedef ip-version {
      type enumeration {
         enum unknown {
            value 0;
            description "An unknown or unspecified version of the Internet
          protocol.";
         }
         enum ipv4 {
            value 1;
            description "The IPv4 protocol as defined in RFC 791.";
         }
         enum ipv6 {
            value 2;
            description "The IPv6 protocol as defined in RFC 2460.";
         }
      }
      description "This value represents the version of the IP protocol.

      In the value set and its semantics, this type is equivalent
      to the InetVersion textual convention of the SMIv2.";
      reference "RFC  791: Internet Protocol
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification
      RFC 4001: Textual Conventions for Internet Network Addresses";
   }
   typedef dscp {
      type uint8 {
         range 0..63;
      }
      description "The dscp type represents a Differentiated Services Code Point
      that may be used for marking packets in a traffic stream.

      In the value set and its semantics, this type is equivalent
      to the Dscp textual convention of the SMIv2.";
      reference "RFC 3289: Management Information Base for the Differentiated
                Services Architecture
      RFC 2474: Definition of the Differentiated Services Field
                (DS Field) in the IPv4 and IPv6 Headers
      RFC 2780: IANA Allocation Guidelines For Values In
                the Internet Protocol and Related Headers";
   }
   typedef ipv6-flow-label {
      type uint32 {
         range 0..1048575;
      }
      description "The ipv6-flow-label type represents the flow identifier or
      Flow Label in an IPv6 packet header that may be used to
      discriminate traffic flows.

      In the value set and its semantics, this type is equivalent
      to the IPv6FlowLabel textual convention of the SMIv2.";
      reference "RFC 3595: Textual Conventions for IPv6 Flow Label
      RFC 2460: Internet Protocol, Version 6 (IPv6) Specification";
   }
   typedef port-number {
      type uint16 {
         range 0..65535;
      }
      description "The port-number type represents a 16-bit port number of an
      Internet transport-layer protocol such as UDP, TCP, DCCP, or
      SCTP.  Port numbers are assigned by IANA.  A current list of
      all assignments is available from <http://www.iana.org/>.

      Note that the port number value zero is reserved by IANA.  In
      situations where the value zero does not make sense, it can
      be excluded by subtyping the port-number type.
      In the value set and its semantics, this type is equivalent
      to the InetPortNumber textual convention of the SMIv2.";
      reference "RFC  768: User Datagram Protocol
      RFC  793: Transmission Control Protocol
      RFC 4960: Stream Control Transmission Protocol
      RFC 4340: Datagram Congestion Control Protocol (DCCP)
      RFC 4001: Textual Conventions for Internet Network Addresses";
   }
   typedef as-number {
      type uint32;
      description "The as-number type represents autonomous system numbers
      which identify an Autonomous System (AS).  An AS is a set
      of routers under a single technical administration, using
      an interior gateway protocol and common metrics to route
      packets within the AS, and using an exterior gateway
      protocol to route packets to other ASes.  IANA maintains
      the AS number space and has delegated large parts to the
      regional registries.

      Autonomous system numbers were originally limited to 16
      bits.  BGP extensions have enlarged the autonomous system
      number space to 32 bits.  This type therefore uses an uint32
      base type without a range restriction in order to support
      a larger autonomous system number space.

      In the value set and its semantics, this type is equivalent
      to the InetAutonomousSystemNumber textual convention of
      the SMIv2.";
      reference "RFC 1930: Guidelines for creation, selection, and registration
                of an Autonomous System (AS)
      RFC 4271: A Border Gateway Protocol 4 (BGP-4)
      RFC 4001: Textual Conventions for Internet Network Addresses
      RFC 6793: BGP Support for Four-Octet Autonomous System (AS)
                Number Space";
   }
   typedef ip-address {
      type union {
         type inet:ipv4-address;
         type inet:ipv6-address;
      }
      description "The ip-address type represents an IP address and is IP
      version neutral.  The format of the textual representation
      implies the IP version.  This type supports scoped addresses
      by allowing zone identifiers in the address format.";
      reference "RFC 4007: IPv6 Scoped Address Architecture";
   }
   typedef ipv4-address {
      type string {
         pattern (([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(%[\p{N}\p{L}]+)?;
      }
      description "The ipv4-address type represents an IPv4 address in
       dotted-quad notation.  The IPv4 address may include a zone
       index, separated by a % sign.

       The zone index is used to disambiguate identical address
       values.  For link-local addresses, the zone index will
       typically be the interface index number or the name of an
       interface.  If the zone index is not present, the default
       zone of the device will be used.

       The canonical format for the zone index is the numerical
       format";
   }
   typedef ipv6-address {
      type string {
         pattern ((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(%[\p{N}\p{L}]+)?;
         pattern (([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(%.+)?;
      }
      description "The ipv6-address type represents an IPv6 address in full,
      mixed, shortened, and shortened-mixed notation.  The IPv6
      address may include a zone index, separated by a % sign.

      The zone index is used to disambiguate identical address
      values.  For link-local addresses, the zone index will
      typically be the interface index number or the name of an
      interface.  If the zone index is not present, the default
      zone of the device will be used.

      The canonical format of IPv6 addresses uses the textual
      representation defined in Section 4 of RFC 5952.  The
      canonical format for the zone index is the numerical
      format as described in Section 11.2 of RFC 4007.";
      reference "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
   }
   typedef ip-address-no-zone {
      type union {
         type inet:ipv4-address-no-zone;
         type inet:ipv6-address-no-zone;
      }
      description "The ip-address-no-zone type represents an IP address and is
      IP version neutral.  The format of the textual representation
      implies the IP version.  This type does not support scoped
      addresses since it does not allow zone identifiers in the
      address format.";
      reference "RFC 4007: IPv6 Scoped Address Architecture";
   }
   typedef ipv4-address-no-zone {
      type inet:ipv4-address {
         pattern [0-9\.]*;
      }
      description "An IPv4 address without a zone index.  This type, derived from
       ipv4-address, may be used in situations where the zone is known
       from the context and hence no zone index is needed.";
   }
   typedef ipv6-address-no-zone {
      type inet:ipv6-address {
         pattern [0-9a-fA-F:\.]*;
      }
      description "An IPv6 address without a zone index.  This type, derived from
       ipv6-address, may be used in situations where the zone is known
       from the context and hence no zone index is needed.";
      reference "RFC 4291: IP Version 6 Addressing Architecture
      RFC 4007: IPv6 Scoped Address Architecture
      RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
   }
   typedef ip-prefix {
      type union {
         type inet:ipv4-prefix;
         type inet:ipv6-prefix;
      }
      description "The ip-prefix type represents an IP prefix and is IP
      version neutral.  The format of the textual representations
      implies the IP version.";
   }
   typedef ipv4-prefix {
      type string {
         pattern (([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]));
      }
      description "The ipv4-prefix type represents an IPv4 prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 32.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format of an IPv4 prefix has all bits of
      the IPv4 address set to zero that are not part of the
      IPv4 prefix.

      The definition of ipv4-prefix does not require that bits,
      which are not part of the prefix, are set to zero. However,
      implementations have to return values in canonical format,
      which requires non-prefix bits to be set to zero. This means
      that 192.0.2.1/24 must be accepted as a valid value but it
      will be converted into the canonical format 192.0.2.0/24.";
   }
   typedef ipv6-prefix {
      type string {
         pattern ((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])));
         pattern (([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+);
      }
      description "The ipv6-prefix type represents an IPv6 prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 128.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format of an IPv6 prefix has all bits of
      the IPv6 address set to zero that are not part of the
      IPv6 prefix.  Furthermore, the IPv6 address is represented
      as defined in Section 4 of RFC 5952.

      The definition of ipv6-prefix does not require that bits,
      which are not part of the prefix, are set to zero. However,
      implementations have to return values in canonical format,
      which requires non-prefix bits to be set to zero. This means
      that 2001:db8::1/64 must be accepted as a valid value but it
      will be converted into the canonical format 2001:db8::/64.";
      reference "RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
   }
   typedef ip-address-and-prefix {
      type union {
         type inet:ipv4-address-and-prefix;
         type inet:ipv6-address-and-prefix;
      }
      description "The ip-address-and-prefix type represents an IP address and
      prefix and is IP version neutral.  The format of the textual
      representations implies the IP version.";
   }
   typedef ipv4-address-and-prefix {
      type string {
         pattern (([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])/(([0-9])|([1-2][0-9])|(3[0-2]));
      }
      description "The ipv4-address-and-prefix type represents an IPv4
      address and an associated ipv4 prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 32.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.";
   }
   typedef ipv6-address-and-prefix {
      type string {
         pattern ((:|[0-9a-fA-F]{0,4}):)([0-9a-fA-F]{0,4}:){0,5}((([0-9a-fA-F]{0,4}:)?(:|[0-9a-fA-F]{0,4}))|(((25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9]?[0-9])))(/(([0-9])|([0-9]{2})|(1[0-1][0-9])|(12[0-8])));
         pattern (([^:]+:){6}(([^:]+:[^:]+)|(.*\..*)))|((([^:]+:)*[^:]+)?::(([^:]+:)*[^:]+)?)(/.+);
      }
      description "The ipv6-address-and-prefix type represents an IPv6
      address and an associated ipv4 prefix.
      The prefix length is given by the number following the
      slash character and must be less than or equal to 128.

      A prefix length value of n corresponds to an IP address
      mask that has n contiguous 1-bits from the most
      significant bit (MSB) and all other bits set to 0.

      The canonical format requires that the IPv6 address is
      represented as defined in Section 4 of RFC 5952.";
      reference "RFC 5952: A Recommendation for IPv6 Address Text
                Representation";
   }
   typedef domain-name {
      type string {
         length 1..253;
         pattern ((([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.)*([a-zA-Z0-9_]([a-zA-Z0-9\-_]){0,61})?[a-zA-Z0-9]\.?)|\.;
      }
      description "The domain-name type represents a DNS domain name.  The
      name SHOULD be fully qualified whenever possible. This
      type does not support wildcards (see RFC 4592) or
      classless in-addr.arpa delegations (see RFC 2317).

      Internet domain names are only loosely specified.  Section
      3.5 of RFC 1034 recommends a syntax (modified in Section
      2.1 of RFC 1123).  The pattern above is intended to allow
      for current practice in domain name use, and some possible
      future expansion.  Note that Internet host names have a
      stricter syntax (described in RFC 952) than the DNS
      recommendations in RFCs 1034 and 1123. Schema nodes
      representing host names should use the host-name type
      instead of the domain-type.

      The encoding of DNS names in the DNS protocol is limited
      to 255 characters.  Since the encoding consists of labels
      prefixed by a length bytes and there is a trailing NULL
      byte, only 253 characters can appear in the textual dotted
      notation.

      The description clause of schema nodes using the domain-name
      type MUST describe when and how these names are resolved to
      IP addresses.  Note that the resolution of a domain-name value
      may require to query multiple DNS records (e.g., A for IPv4
      and AAAA for IPv6).  The order of the resolution process and
      which DNS record takes precedence can either be defined
      explicitly or may depend on the configuration of the
      resolver.

      Domain-name values use the US-ASCII encoding.  Their canonical
      format uses lowercase US-ASCII characters.  Internationalized
      domain names MUST be A-labels as per RFC 5890.";
      reference "RFC  952: DoD Internet Host Table Specification
      RFC 1034: Domain Names - Concepts and Facilities
      RFC 1123: Requirements for Internet Hosts -- Application
                and Support
      RFC 2317: Classless IN-ADDR.ARPA delegation
      RFC 2782: A DNS RR for specifying the location of services
                (DNS SRV)
      RFC 4592: The Role of Wildcards in the Domain Name System
      RFC 5890: Internationalized Domain Names in Applications
                (IDNA): Definitions and Document Framework";
   }
   typedef host-name {
      type domain-name {
         pattern [a-zA-Z0-9\-\.]+;
         length 2..max;
      }
      description "The host-name type represents (fully qualified) host names.
      Host names must be at least two characters long (see RFC 952)
      and they are restricted to labels consisting of letters, digits
      and hyphens separated by dots (see RFC1123 and RFC 952).";
      reference "RFC  952: DoD Internet Host Table Specification
      RFC 1123: Requirements for Internet Hosts: Application and Support";
   }
   typedef host {
      type union {
         type inet:ip-address;
         type inet:host-name;
      }
      description "The host type represents either an IP address or a (fully
      qualified) host name.";
   }
   typedef uri {
      type string;
      description "The uri type represents a Uniform Resource Identifier
      (URI) as defined by STD 66.

      Objects using the uri type MUST be in US-ASCII encoding,
      and MUST be normalized as described by RFC 3986 Sections
      6.2.1, 6.2.2.1, and 6.2.2.2.  All unnecessary
      percent-encoding is removed, and all case-insensitive
      characters are set to lowercase except for hexadecimal
      digits, which are normalized to uppercase as described in
      Section 6.2.2.1.

      The purpose of this normalization is to help provide
      unique URIs.  Note that this normalization is not
      sufficient to provide uniqueness.  Two URIs that are
      textually distinct after this normalization may still be
      equivalent.

      Objects using the uri type may restrict the schemes that
      they permit.  For example, 'data:' and 'urn:' schemes
      might not be appropriate.

      A zero-length URI is not a valid URI.  This can be used to
      express 'URI absent' where required.

      In the value set and its semantics, this type is equivalent
      to the Uri SMIv2 textual convention defined in RFC 5017.";
      reference "RFC 3986: Uniform Resource Identifier (URI): Generic Syntax
      RFC 3305: Report from the Joint W3C/IETF URI Planning Interest
                Group: Uniform Resource Identifiers (URIs), URLs,
                and Uniform Resource Names (URNs): Clarifications
                and Recommendations
      RFC 5017: MIB Textual Conventions for Uniform Resource
                Identifiers (URIs)";
   }
   typedef email-address {
      type string {
         pattern [a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*;
      }
      description "The email-address type represents an email address as
       defined as addr-spec in RFC 5322 section 3.4.1.";
      reference "RFC 5322: Internet Message Format";
   }
}
module ietf-yang-metadata {
   namespace urn:ietf:params:xml:ns:yang:ietf-yang-metadata;
   prefix md;
   organization "IETF NETMOD (NETCONF Data Modeling Language) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

     WG List:  <mailto:netmod@ietf.org>

     WG Chair: Lou Berger
               <mailto:lberger@labn.net>

     WG Chair: Kent Watsen
               <mailto:kwatsen@juniper.net>

     Editor:   Ladislav Lhotka
               <mailto:lhotka@nic.cz>";
   description "This YANG module defines an 'extension' statement that allows
     for defining metadata annotations.

     Copyright (c) 2016 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 7952
     (http://www.rfc-editor.org/info/rfc7952); see the RFC itself
     for full legal notices.";
   revision 2016-08-05 {
      description "Initial revision.";
      reference "RFC 7952: Defining and Using Metadata with YANG";
   }
   extension annotation {
      argument name;
      description "This extension allows for defining metadata annotations in
       YANG modules.  The 'md:annotation' statement can appear only
       at the top level of a YANG module or submodule, i.e., it
       becomes a new alternative in the ABNF production rule for
       'body-stmts' (Section 14 in RFC 7950).

       The argument of the 'md:annotation' statement defines the name
       of the annotation.  Syntactically, it is a YANG identifier as
       defined in Section 6.2 of RFC 7950.

       An annotation defined with this 'extension' statement inherits
       the namespace and other context from the YANG module in which
       it is defined.

       The data type of the annotation value is specified in the same
       way as for a leaf data node using the 'type' statement.

       The semantics of the annotation and other documentation can be
       specified using the following standard YANG substatements (all
       are optional): 'description', 'if-feature', 'reference',
       'status', and 'units'.

       A server announces support for a particular annotation by
       including the module in which the annotation is defined among
       the advertised YANG modules, e.g., in a NETCONF <hello>
       message or in the YANG library (RFC 7950).  The annotation can
       then be attached to any instance of a data node defined in any
       YANG module that is advertised by the server.

       XML encoding and JSON encoding of annotations are defined in
       RFC 7952.";
   }
}
module ietf-netconf {
   namespace urn:ietf:params:xml:ns:netconf:base:1.0;
   prefix nc;
   import ietf-inet-types {
      prefix inet;
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   <http://tools.ietf.org/wg/netconf/>
       WG List:  <netconf@ietf.org>

       WG Chair: Bert Wijnen
                 <bertietf@bwijnen.net>

       WG Chair: Mehmet Ersue
                 <mehmet.ersue@nsn.com>

       Editor:   Martin Bjorklund
                 <mbj@tail-f.com>

       Editor:   Juergen Schoenwaelder
                 <j.schoenwaelder@jacobs-university.de>

       Editor:   Andy Bierman
                 <andy.bierman@brocade.com>";
   description "NETCONF Protocol Data Types and Protocol Operations.

       Copyright (c) 2011 IETF Trust and the persons identified as
       the document authors.  All rights reserved.

       Redistribution and use in source and binary forms, with or
       without modification, is permitted pursuant to, and subject
       to the license terms contained in, the Simplified BSD License
       set forth in Section 4.c of the IETF Trust's Legal Provisions
       Relating to IETF Documents
       (http://trustee.ietf.org/license-info).

       This version of this YANG module is part of RFC 6241; see
       the RFC itself for full legal notices.";
   revision 2011-06-01 {
      description "Initial revision";
      reference "RFC 6241: Network Configuration Protocol";
   }
   extension get-filter-element-attributes {
      description "If this extension is present within an 'anyxml'
         statement named 'filter', which must be conceptually
         defined within the RPC input section for the <get>
         and <get-config> protocol operations, then the
         following unqualified XML attribute is supported
         within the <filter> element, within a <get> or
         <get-config> protocol operation:

           type : optional attribute with allowed
                  value strings 'subtree' and 'xpath'.
                  If missing, the default value is 'subtree'.

         If the 'xpath' feature is supported, then the
         following unqualified XML attribute is
         also supported:

           select: optional attribute containing a
                   string representing an XPath expression.
                   The 'type' attribute must be equal to 'xpath'
                   if this attribute is present.";
   }
   feature writable-running {
      description "NETCONF :writable-running capability;
         If the server advertises the :writable-running
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.2";
   }
   feature candidate {
      description "NETCONF :candidate capability;
         If the server advertises the :candidate
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.3";
   }
   feature confirmed-commit {
      if-feature candidate;
      description "NETCONF :confirmed-commit:1.1 capability;
         If the server advertises the :confirmed-commit:1.1
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.4";
   }
   feature rollback-on-error {
      description "NETCONF :rollback-on-error capability;
         If the server advertises the :rollback-on-error
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.5";
   }
   feature validate {
      description "NETCONF :validate:1.1 capability;
         If the server advertises the :validate:1.1
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.6";
   }
   feature startup {
      description "NETCONF :startup capability;
         If the server advertises the :startup
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.7";
   }
   feature url {
      description "NETCONF :url capability;
         If the server advertises the :url
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.8";
   }
   feature xpath {
      description "NETCONF :xpath capability;
         If the server advertises the :xpath
         capability for a session, then this feature must
         also be enabled for that session.  Otherwise,
         this feature must not be enabled.";
      reference "RFC 6241, Section 8.9";
   }
   typedef session-id-type {
      type uint32 {
         range 1..max;
      }
      description "NETCONF Session Id";
   }
   typedef session-id-or-zero-type {
      type uint32;
      description "NETCONF Session Id or Zero to indicate none";
   }
   typedef error-tag-type {
      type enumeration {
         enum in-use {
            description "The request requires a resource that
              already is in use.";
         }
         enum invalid-value {
            description "The request specifies an unacceptable value for one
              or more parameters.";
         }
         enum too-big {
            description "The request or response (that would be generated) is
              too large for the implementation to handle.";
         }
         enum missing-attribute {
            description "An expected attribute is missing.";
         }
         enum bad-attribute {
            description "An attribute value is not correct; e.g., wrong type,
              out of range, pattern mismatch.";
         }
         enum unknown-attribute {
            description "An unexpected attribute is present.";
         }
         enum missing-element {
            description "An expected element is missing.";
         }
         enum bad-element {
            description "An element value is not correct; e.g., wrong type,
              out of range, pattern mismatch.";
         }
         enum unknown-element {
            description "An unexpected element is present.";
         }
         enum unknown-namespace {
            description "An unexpected namespace is present.";
         }
         enum access-denied {
            description "Access to the requested protocol operation or
              data model is denied because authorization failed.";
         }
         enum lock-denied {
            description "Access to the requested lock is denied because the
              lock is currently held by another entity.";
         }
         enum resource-denied {
            description "Request could not be completed because of
              insufficient resources.";
         }
         enum rollback-failed {
            description "Request to roll back some configuration change (via
              rollback-on-error or <discard-changes> operations)
              was not completed for some reason.";
         }
         enum data-exists {
            description "Request could not be completed because the relevant
              data model content already exists.  For example,
              a 'create' operation was attempted on data that
              already exists.";
         }
         enum data-missing {
            description "Request could not be completed because the relevant
              data model content does not exist.  For example,
              a 'delete' operation was attempted on
              data that does not exist.";
         }
         enum operation-not-supported {
            description "Request could not be completed because the requested
              operation is not supported by this implementation.";
         }
         enum operation-failed {
            description "Request could not be completed because the requested
              operation failed for some reason not covered by
              any other error condition.";
         }
         enum partial-operation {
            description "This error-tag is obsolete, and SHOULD NOT be sent
              by servers conforming to this document.";
         }
         enum malformed-message {
            description "A message could not be handled because it failed to
              be parsed correctly.  For example, the message is not
              well-formed XML or it uses an invalid character set.";
         }
      }
      description "NETCONF Error Tag";
      reference "RFC 6241, Appendix A";
   }
   typedef error-severity-type {
      type enumeration {
         enum error {
            description "Error severity";
         }
         enum warning {
            description "Warning severity";
         }
      }
      description "NETCONF Error Severity";
      reference "RFC 6241, Section 4.3";
   }
   typedef edit-operation-type {
      type enumeration {
         enum merge {
            description "The configuration data identified by the
             element containing this attribute is merged
             with the configuration at the corresponding
             level in the configuration datastore identified
             by the target parameter.";
         }
         enum replace {
            description "The configuration data identified by the element
             containing this attribute replaces any related
             configuration in the configuration datastore
             identified by the target parameter.  If no such
             configuration data exists in the configuration
             datastore, it is created.  Unlike a
             <copy-config> operation, which replaces the
             entire target configuration, only the configuration
             actually present in the config parameter is affected.";
         }
         enum create {
            description "The configuration data identified by the element
             containing this attribute is added to the
             configuration if and only if the configuration
             data does not already exist in the configuration
             datastore.  If the configuration data exists, an
             <rpc-error> element is returned with an
             <error-tag> value of 'data-exists'.";
         }
         enum delete {
            description "The configuration data identified by the element
             containing this attribute is deleted from the
             configuration if and only if the configuration
             data currently exists in the configuration
             datastore.  If the configuration data does not
             exist, an <rpc-error> element is returned with
             an <error-tag> value of 'data-missing'.";
         }
         enum remove {
            description "The configuration data identified by the element
             containing this attribute is deleted from the
             configuration if the configuration
             data currently exists in the configuration
             datastore.  If the configuration data does not
             exist, the 'remove' operation is silently ignored
             by the server.";
         }
      }
      default merge;
      description "NETCONF 'operation' attribute values";
      reference "RFC 6241, Section 7.2";
   }
   rpc get-config {
      description "Retrieve all or part of a specified configuration.";
      reference "RFC 6241, Section 7.1";
      input {
         container source {
            description "Particular configuration to retrieve.";
            choice config-source {
               mandatory true;
               description "The configuration to retrieve.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config source.";
               }
               leaf running {
                  type empty;
                  description "The running configuration is the config source.";
               }
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config source.
                 This is optional-to-implement on the server because
                 not all servers will support filtering for this
                 datastore.";
               }
            }
         }
         anyxml filter {
            description "Subtree or XPath filter to use.";
         }
         leaf with-defaults {
            description "The explicit defaults processing mode requested.";
            reference "RFC 6243; Section 4.5.1";
            type with-defaults-mode;
         }
         container list-pagination {
            description "List pagination parameters.";
            uses lpg:where-param-grouping;
            leaf where {
               type union {
                  type yang:xpath1.0;
                  type enumeration {
                     enum unfiltered {
                        description "Indicates that no entries are to be filtered
               from the working result-set.";
                     }
                  }
               }
               default unfiltered;
               description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
            }
            uses lpg:sort-by-param-grouping;
            leaf sort-by {
               type union {
                  type string {
                     pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
                  }
                  type enumeration {
                     enum none {
                        description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                     }
                  }
               }
               default none;
               description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
            }
            uses lpg:locale-param-grouping;
            leaf locale {
               type string;
               description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
            }
            uses lpg:direction-param-grouping;
            leaf direction {
               type enumeration {
                  enum forwards {
                     description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
                  }
                  enum backwards {
                     description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
                  }
               }
               default forwards;
               description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
            }
            uses lpg:cursor-param-grouping;
            leaf cursor {
               type string;
               description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
            }
            uses lpg:offset-param-grouping;
            leaf offset {
               type uint32;
               default 0;
               description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
            }
            uses lpg:limit-param-grouping;
            leaf limit {
               type union {
                  type uint32 {
                     range 1..max;
                  }
                  type enumeration {
                     enum unbounded {
                        description "Indicates that the number of entries that may be
               returned is unbounded.";
                     }
                  }
               }
               default unbounded;
               description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
            }
            uses lpg:sublist-limit-param-grouping;
            leaf sublist-limit {
               type union {
                  type uint32 {
                     range 1..max;
                  }
                  type enumeration {
                     enum unbounded {
                        description "Indicates that the number of entries that may be
               returned is unbounded.";
                     }
                  }
               }
               default unbounded;
               description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
            }
         }
      }
      output {
         anyxml data {
            description "Copy of the source datastore subset that matched
             the filter criteria (if any).  An empty data container
             indicates that the request did not produce any results.";
         }
      }
   }
   rpc edit-config {
      description "The <edit-config> operation loads all or part of a specified
         configuration to the specified target configuration.";
      reference "RFC 6241, Section 7.2";
      input {
         container target {
            description "Particular configuration to edit.";
            choice config-target {
               mandatory true;
               description "The configuration target.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config target.";
               }
            }
         }
         leaf default-operation {
            type enumeration {
               enum merge {
                  description "The default operation is merge.";
               }
               enum replace {
                  description "The default operation is replace.";
               }
               enum none {
                  description "There is no default operation.";
               }
            }
            default merge;
            description "The default operation to use.";
         }
         leaf test-option {
            if-feature validate;
            type enumeration {
               enum test-then-set {
                  description "The server will test and then set if no errors.";
               }
               enum set {
                  description "The server will set without a test first.";
               }
               enum test-only {
                  description "The server will only test and not set, even
                 if there are no errors.";
               }
            }
            default test-then-set;
            description "The test option to use.";
         }
         leaf error-option {
            type enumeration {
               enum stop-on-error {
                  description "The server will stop on errors.";
               }
               enum continue-on-error {
                  description "The server may continue on errors.";
               }
               enum rollback-on-error {
                  description "The server will roll back on errors.
                 This value can only be used if the 'rollback-on-error'
                 feature is supported.";
               }
            }
            default stop-on-error;
            description "The error option to use.";
         }
         choice edit-content {
            mandatory true;
            description "The content for the edit operation.";
            anyxml config {
               description "Inline Config content.";
            }
         }
      }
   }
   rpc copy-config {
      description "Create or replace an entire configuration datastore with the
         contents of another complete configuration datastore.";
      reference "RFC 6241, Section 7.3";
      input {
         container target {
            description "Particular configuration to copy to.";
            choice config-target {
               mandatory true;
               description "The configuration target of the copy operation.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config target.";
               }
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config target.";
               }
            }
         }
         container source {
            description "Particular configuration to copy from.";
            choice config-source {
               mandatory true;
               description "The configuration source for the copy operation.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config source.";
               }
               leaf running {
                  type empty;
                  description "The running configuration is the config source.";
               }
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config source.";
               }
               anyxml config {
                  description "Inline Config content: <config> element.  Represents
                 an entire configuration datastore, not
                 a subset of the running datastore.";
               }
            }
         }
         leaf with-defaults {
            description "The explicit defaults processing mode requested.";
            reference "RFC 6243; Section 4.5.1";
            type with-defaults-mode;
         }
      }
   }
   rpc delete-config {
      description "Delete a configuration datastore.";
      reference "RFC 6241, Section 7.4";
      input {
         container target {
            description "Particular configuration to delete.";
            choice config-target {
               mandatory true;
               description "The configuration target to delete.";
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config target.";
               }
            }
         }
      }
   }
   rpc lock {
      description "The lock operation allows the client to lock the configuration
         system of a device.";
      reference "RFC 6241, Section 7.5";
      input {
         container target {
            description "Particular configuration to lock.";
            choice config-target {
               mandatory true;
               description "The configuration target to lock.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config target.";
               }
               leaf running {
                  type empty;
                  description "The running configuration is the config target.";
               }
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config target.";
               }
               leaf datastore {
                  type ds:datastore-ref;
                  description "Datastore to lock.

         The <lock> operation is only supported on writable
         datastores.

         If the <lock> operation is not supported by the server on
         the specified target datastore, then the server MUST return
         an <rpc-error> element with an <error-tag> value of
         'invalid-value'.";
               }
            }
         }
      }
   }
   rpc unlock {
      description "The unlock operation is used to release a configuration lock,
         previously obtained with the 'lock' operation.";
      reference "RFC 6241, Section 7.6";
      input {
         container target {
            description "Particular configuration to unlock.";
            choice config-target {
               mandatory true;
               description "The configuration target to unlock.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config target.";
               }
               leaf running {
                  type empty;
                  description "The running configuration is the config target.";
               }
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config target.";
               }
               leaf datastore {
                  type ds:datastore-ref;
                  description "Datastore to unlock.

         The <unlock> operation is only supported on writable
         datastores.

         If the <unlock> operation is not supported by the server on
         the specified target datastore, then the server MUST return
         an <rpc-error> element with an <error-tag> value of
         'invalid-value'.";
               }
            }
         }
      }
   }
   rpc get {
      description "Retrieve running configuration and device state information.";
      reference "RFC 6241, Section 7.7";
      input {
         anyxml filter {
            description "This parameter specifies the portion of the system
             configuration and state data to retrieve.";
         }
         leaf with-defaults {
            description "The explicit defaults processing mode requested.";
            reference "RFC 6243; Section 4.5.1";
            type with-defaults-mode;
         }
         container list-pagination {
            description "List pagination parameters.";
            uses lpg:where-param-grouping;
            leaf where {
               type union {
                  type yang:xpath1.0;
                  type enumeration {
                     enum unfiltered {
                        description "Indicates that no entries are to be filtered
               from the working result-set.";
                     }
                  }
               }
               default unfiltered;
               description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
            }
            uses lpg:sort-by-param-grouping;
            leaf sort-by {
               type union {
                  type string {
                     pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
                  }
                  type enumeration {
                     enum none {
                        description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                     }
                  }
               }
               default none;
               description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
            }
            uses lpg:locale-param-grouping;
            leaf locale {
               type string;
               description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
            }
            uses lpg:direction-param-grouping;
            leaf direction {
               type enumeration {
                  enum forwards {
                     description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
                  }
                  enum backwards {
                     description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
                  }
               }
               default forwards;
               description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
            }
            uses lpg:cursor-param-grouping;
            leaf cursor {
               type string;
               description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
            }
            uses lpg:offset-param-grouping;
            leaf offset {
               type uint32;
               default 0;
               description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
            }
            uses lpg:limit-param-grouping;
            leaf limit {
               type union {
                  type uint32 {
                     range 1..max;
                  }
                  type enumeration {
                     enum unbounded {
                        description "Indicates that the number of entries that may be
               returned is unbounded.";
                     }
                  }
               }
               default unbounded;
               description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
            }
            uses lpg:sublist-limit-param-grouping;
            leaf sublist-limit {
               type union {
                  type uint32 {
                     range 1..max;
                  }
                  type enumeration {
                     enum unbounded {
                        description "Indicates that the number of entries that may be
               returned is unbounded.";
                     }
                  }
               }
               default unbounded;
               description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
            }
         }
      }
      output {
         anyxml data {
            description "Copy of the running datastore subset and/or state
             data that matched the filter criteria (if any).
             An empty data container indicates that the request did not
             produce any results.";
         }
      }
   }
   rpc close-session {
      description "Request graceful termination of a NETCONF session.";
      reference "RFC 6241, Section 7.8";
   }
   rpc kill-session {
      description "Force the termination of a NETCONF session.";
      reference "RFC 6241, Section 7.9";
      input {
         leaf session-id {
            type session-id-type;
            mandatory true;
            description "Particular session to kill.";
         }
      }
   }
   rpc commit {
      if-feature candidate;
      description "Commit the candidate configuration as the device's new
         current configuration.";
      reference "RFC 6241, Section 8.3.4.1";
      input {
         leaf confirmed {
            if-feature confirmed-commit;
            type empty;
            description "Requests a confirmed commit.";
            reference "RFC 6241, Section 8.3.4.1";
         }
         leaf confirm-timeout {
            if-feature confirmed-commit;
            type uint32 {
               range 1..max;
            }
            units seconds;
            default 600;
            description "The timeout interval for a confirmed commit.";
            reference "RFC 6241, Section 8.3.4.1";
         }
         leaf persist {
            if-feature confirmed-commit;
            type string;
            description "This parameter is used to make a confirmed commit
             persistent.  A persistent confirmed commit is not aborted
             if the NETCONF session terminates.  The only way to abort
             a persistent confirmed commit is to let the timer expire,
             or to use the <cancel-commit> operation.

             The value of this parameter is a token that must be given
             in the 'persist-id' parameter of <commit> or
             <cancel-commit> operations in order to confirm or cancel
             the persistent confirmed commit.

             The token should be a random string.";
            reference "RFC 6241, Section 8.3.4.1";
         }
         leaf persist-id {
            if-feature confirmed-commit;
            type string;
            description "This parameter is given in order to commit a persistent
             confirmed commit.  The value must be equal to the value
             given in the 'persist' parameter to the <commit> operation.
             If it does not match, the operation fails with an
            'invalid-value' error.";
            reference "RFC 6241, Section 8.3.4.1";
         }
      }
   }
   rpc discard-changes {
      if-feature candidate;
      description "Revert the candidate configuration to the current
         running configuration.";
      reference "RFC 6241, Section 8.3.4.2";
   }
   rpc cancel-commit {
      if-feature confirmed-commit;
      description "This operation is used to cancel an ongoing confirmed commit.
         If the confirmed commit is persistent, the parameter
         'persist-id' must be given, and it must match the value of the
         'persist' parameter.";
      reference "RFC 6241, Section 8.4.4.1";
      input {
         leaf persist-id {
            type string;
            description "This parameter is given in order to cancel a persistent
             confirmed commit.  The value must be equal to the value
             given in the 'persist' parameter to the <commit> operation.
             If it does not match, the operation fails with an
            'invalid-value' error.";
         }
      }
   }
   rpc validate {
      if-feature validate;
      description "Validates the contents of the specified configuration.";
      reference "RFC 6241, Section 8.6.4.1";
      input {
         container source {
            description "Particular configuration to validate.";
            choice config-source {
               mandatory true;
               description "The configuration source to validate.";
               leaf candidate {
                  if-feature candidate;
                  type empty;
                  description "The candidate configuration is the config source.";
               }
               leaf running {
                  type empty;
                  description "The running configuration is the config source.";
               }
               leaf startup {
                  if-feature startup;
                  type empty;
                  description "The startup configuration is the config source.";
               }
               anyxml config {
                  description "Inline Config content: <config> element.  Represents
                 an entire configuration datastore, not
                 a subset of the running datastore.";
               }
               leaf datastore {
                  type ds:datastore-ref;
                  description "Datastore to validate.

         The <validate> operation is supported only on configuration
         datastores.

         If the <validate> operation is not supported by the server
         on the specified target datastore, then the server MUST
         return an <rpc-error> element with an <error-tag> value of
         'invalid-value'.";
               }
            }
         }
      }
   }
}
module clixon-rfc5277 {
   namespace urn:ietf:params:xml:ns:netmod:notification;
   prefix ncevent;
   import ietf-yang-types {
      prefix yang;
   }
   import ietf-inet-types {
      prefix inet;
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   description "Note this is a translation from RFC 5277 schema in section 4 to Yang
         made by Olof Hagsand manually for the Clixon project.
         RFC 5277 is Copyright (C) The IETF Trust (2008).";
   revision 2008-07-01 {
      description "Initial revision.";
      reference "RFC 5277: NETCONF Event Notifications.";
   }
   container netconf {
      config false;
      description "Contains NETCONF protocol monitoring information.";
      container capabilities {
         description "Contains a list of protocol capability URIs.";
         leaf-list capability {
            type inet:uri;
            description "A RESTCONF protocol capability URI.";
         }
      }
      container streams {
         description "Container representing the notification event streams
            supported by the server.";
         reference "RFC 5277, Section 3.4, <streams> element.";
         list stream {
            key name;
            description "Each entry describes an event stream supported by
              the server.";
            leaf name {
               type string;
               description "The stream name.";
               reference "RFC 5277, Section 3.4, <name> element.";
            }
            leaf description {
               type string;
               description "Description of stream content.";
               reference "RFC 5277, Section 3.4, <description> element.";
            }
            leaf replay-support {
               type boolean;
               default false;
               description "Indicates if replay buffer is supported for this stream.
                If 'true', then the server MUST support the 'start-time'
                and 'stop-time' query parameters for this stream.";
               reference "RFC 5277, Section 3.4, <replaySupport> element.";
            }
            leaf replay-log-creation-time {
               when ../replay-support {
                  description "Only present if notification replay is supported.";
               }
               type yang:date-and-time;
               description "Indicates the time the replay log for this stream
                was created.";
               reference "RFC 5277, Section 3.4, <replayLogCreationTime>
                element.";
            }
         }
      }
   }
   rpc create-subscription {
      description "The command to create a notification subscription.  It
                takes as argument the name of the notification stream
                and filter.  Both of those options
                limit the content of the subscription.  In addition,
                there are two time-related parameters, startTime and
                stopTime, which can be used to select the time interval
                of interest to the notification replay feature.";
      reference "RFC 5277, Section 2.1";
      input {
         leaf stream {
            type string;
            default NETCONF;
            description "An optional parameter, <stream>, that indicates which
                stream of events is of interest.  If not present, events in the
                default NETCONF stream will be sent.";
         }
         leaf filter {
            type string;
            description "An optional parameter, <filter>, that indicates which
               subset of all possible events is of interest.  The format of this
               parameter is the same as that of the filter parameter in the
               NETCONF protocol operations.  If not present, all events not
               precluded by other parameters will be sent.  See section 3.6
               for more information on filters";
         }
         leaf startTime {
            type yang:date-and-time;
            description "used to trigger the replay feature
         and indicate that the replay should start at the time
         specified. If <startTime> is not present, this is not a replay
         subscription.";
         }
         leaf stopTime {
            type yang:date-and-time;
            description "used with the optional
         replay feature to indicate the newest notifications of
         interest.  If <stopTime> is not present, the notifications will
         continue until the subscription is terminated.";
         }
      }
   }
}
module ietf-list-pagination {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-list-pagination;
   prefix lpg;
   import ietf-datastores {
      prefix ds;
      reference "RFC 8342: Network Management Datastore Architecture (NMDA)";
   }
   import ietf-yang-types {
      prefix yang;
      reference "RFC 6991: Common YANG Data Types";
   }
   import ietf-yang-metadata {
      prefix md;
      reference "RFC 7952: Defining and Using Metadata with YANG";
   }
   import ietf-system-capabilities {
      prefix sysc;
      reference "RFC 9196: YANG Modules Describing Capabilities for Systems and
                 Datastore Update Notifications";
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   https://datatracker.ietf.org/wg/netconf
     WG List:  NETCONF WG list <mailto:netconf@ietf.org>";
   description "This module is used by servers to 1) indicate they support
     pagination on 'list' and 'leaf-list' resources, 2) define a
     grouping for each list-pagination parameter, and 3) indicate
     which 'config false' lists have constrained 'where' and
     'sort-by' parameters and how they may be used, if at all.

     Copyright (c) 2024 IETF Trust and the persons identified
     as authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with
     or without modification, is permitted pursuant to, and
     subject to the license terms contained in, the Revised
     BSD License set forth in Section 4.c of the IETF Trust's
     Legal Provisions Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC
     itself for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.";
   revision 2024-10-21 {
      description "Initial revision.";
      reference "RFC XXXX: List Pagination for YANG-driven Protocols";
   }
   md:annotation {
      type union {
         type uint32;
         type enumeration {
            enum unknown {
               description "Indicates that number of remaining entries is unknown
             to the server in case, e.g., the server has determined
             that counting would be prohibitively expensive.";
            }
         }
      }
      description "This annotation contains the number of elements not included
       in the result set (a positive value) due to a 'limit' or
       'sublist-limit' operation.  If no elements were removed,
       this annotation MUST NOT appear.  The minimum value (0),
       which never occurs in normal operation, is reserved to
       represent 'unknown'.  The maximum value (2^32-1) is
       reserved to represent any value greater than or equal
       to 2^32-1 elements.";
   }
   md:annotation {
      type string;
      description "This annotation contains the base64 encoded value of the next
       cursor in the pagination.";
   }
   md:annotation {
      type string;
      description "This annotation contains the base64 encoded value of the
       previous cursor in the pagination.";
   }
   md:annotation {
      type string;
      description "This annotation contains the locale used when sorting.

       The format is a free form string but SHOULD follow the
       language sub-tag format defined in RFC 5646.
       An example is 'sv_SE'.

       For further details see references:
       RFC 5646: Tags for identifying Languages
       RFC 6365: Technology Used in Internationalization in the
                 IETF";
   }
   identity list-pagination-error {
      description "Base identity for list-pagination errors.";
   }
   identity offset-out-of-range {
      base list-pagination-error;
      description "The 'offset' query parameter value is greater than the number
       of instances in the target list or leaf-list resource.";
   }
   identity cursor-not-found {
      base list-pagination-error;
      description "The 'cursor' query parameter value is unknown for the target
       list.";
   }
   identity locale-unavailable {
      base list-pagination-error;
      description "The 'locale' query parameter input is not a valid
       locale or the locale is not available on the system.";
   }
   grouping where-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf where {
         type union {
            type yang:xpath1.0;
            type enumeration {
               enum unfiltered {
                  description "Indicates that no entries are to be filtered
               from the working result-set.";
               }
            }
         }
         default unfiltered;
         description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
      }
   }
   grouping locale-param-grouping {
      description "The grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf locale {
         type string;
         description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
      }
   }
   grouping sort-by-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf sort-by {
         type union {
            type string {
               pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
            }
            type enumeration {
               enum none {
                  description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
               }
            }
         }
         default none;
         description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
      }
   }
   grouping direction-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf direction {
         type enumeration {
            enum forwards {
               description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
            }
            enum backwards {
               description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
            }
         }
         default forwards;
         description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
      }
   }
   grouping cursor-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf cursor {
         type string;
         description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
      }
   }
   grouping offset-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf offset {
         type uint32;
         default 0;
         description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
      }
   }
   grouping limit-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf limit {
         type union {
            type uint32 {
               range 1..max;
            }
            type enumeration {
               enum unbounded {
                  description "Indicates that the number of entries that may be
               returned is unbounded.";
               }
            }
         }
         default unbounded;
         description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
      }
   }
   grouping sublist-limit-param-grouping {
      description "This grouping may be used by protocol-specific YANG modules
       to define a protocol-specific query parameter.";
      leaf sublist-limit {
         type union {
            type uint32 {
               range 1..max;
            }
            type enumeration {
               enum unbounded {
                  description "Indicates that the number of entries that may be
               returned is unbounded.";
               }
            }
         }
         default unbounded;
         description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
      }
   }
   augment /sysc:system-capabilities/sysc:datastore-capabilities/sysc:per-node-capabilities {
      when "/sysc:system-capabilities/sysc:datastore-capabilities/sysc:datastore = 'ds:operational'";
      description "Defines some leafs that MAY be used by the server to
       describe constraints imposed of the 'where' filters and
       'sort-by' parameters used in list pagination queries.";
      leaf constrained {
         type empty;
         description "Indicates that 'where' filters and 'sort-by' parameters
         on the targeted 'config false' list node are constrained.
         If a list is not 'constrained', then full XPath 1.0
         expressions may be used in 'where' filters and all node
         identifiers are usable by 'sort-by'.";
      }
      leaf indexed {
         type empty;
         description "Indicates that the targeted descendent node of a
         'constrained' list (see the 'constrained' leaf) may be
         used in 'where' filters and/or 'sort-by' parameters.
         If a descendent node of a 'constrained' list is not
         'indexed', then it MUST NOT be used in 'where' filters
         or 'sort-by' parameters.";
      }
      leaf cursor-supported {
         type empty;
         description "Indicates that the targeted list node supports the
         'cursor' parameter.";
      }
   }
}
module ietf-datastores {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-datastores;
   prefix ds;
   organization "IETF Network Modeling (NETMOD) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

     WG List:  <mailto:netmod@ietf.org>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Author:   Phil Shafer
               <mailto:phil@juniper.net>

     Author:   Kent Watsen
               <mailto:kwatsen@juniper.net>

     Author:   Rob Wilton
               <rwilton@cisco.com>";
   description "This YANG module defines a set of identities for identifying
     datastores.

     Copyright (c) 2018 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8342
     (https://www.rfc-editor.org/info/rfc8342); see the RFC itself
     for full legal notices.";
   revision 2018-02-14 {
      description "Initial revision.";
      reference "RFC 8342: Network Management Datastore Architecture (NMDA)";
   }
   identity datastore {
      description "Abstract base identity for datastore identities.";
   }
   identity conventional {
      base datastore;
      description "Abstract base identity for conventional configuration
       datastores.";
   }
   identity running {
      base conventional;
      description "The running configuration datastore.";
   }
   identity candidate {
      base conventional;
      description "The candidate configuration datastore.";
   }
   identity startup {
      base conventional;
      description "The startup configuration datastore.";
   }
   identity intended {
      base conventional;
      description "The intended configuration datastore.";
   }
   identity dynamic {
      base datastore;
      description "Abstract base identity for dynamic configuration datastores.";
   }
   identity operational {
      base datastore;
      description "The operational state datastore.";
   }
   typedef datastore-ref {
      type identityref {
         base datastore;
      }
      description "A datastore identity reference.";
   }
}
module ietf-system-capabilities {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-system-capabilities;
   prefix sysc;
   import ietf-netconf-acm {
      prefix nacm;
      reference "RFC 8341: Network Configuration Access Control Model";
   }
   import ietf-yang-library {
      prefix yanglib;
      description "This module requires ietf-yang-library to be implemented.
       Revision 2019-01-04 or a revision derived from it
       is REQUIRED.";
      reference "RFC8525: YANG Library";
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     Editor:   Balazs Lengyel
               <mailto:balazs.lengyel@ericsson.com>";
   description "This module specifies a structure to specify system
     capabilities for a server or a publisher. System capabilities
     may include capabilities of a NETCONF or RESTCONF server or a
     notification publisher.

     This module does not contain any specific capabilities, it only
     provides a structure where containers containing the actual
     capabilities are augmented in.

     Capability values can be specified on system level,
     datastore level (by selecting all nodes in the datastore) or
     for specific data nodes of a specific datastore (and their
     contained sub-trees).
     Capability values specified for a specific datastore or
     node-set override values specified on the system/publisher level.

     To find a capability value for a specific data node in a
     specific datastore the user SHALL:

     1) search for a datastore-capabilities list entry for
     the specific datastore. When stating a specific capability, the
     relative path for any specific capability must be the same
     under the system-capabilities container and under the
     per-node-capabilities list: the same grouping for defining
     the capabilities MUST be used.

     2) If the datastore entry is found within that entry, process all
     per-node-capabilities entries in the order they appear in the list.
     The first entry that specifies the specific capability and has a
     node-selector selecting the specific data node defines the
     capability value.

     3) If the capability value is not found above and the specific
     capability is specified under the system-capabilities container
     (outside the datastore-capabilities list), this value shall be
     used.

     4) If no values are found in the previous steps, the
     system/publisher is not capable of providing a value. Possible
     reasons are: it is unknown, the capability is changing for some
     reason, there is no specified limit, etc. In this case the
     system's behavior is unspecified.
     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.

     Copyright (c) 2021 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC itself
     for full legal notices.";
   revision 2021-04-02 {
      description "Initial version
       NOTE TO RFC EDITOR:
       (1)Please replace the above revision date to
         the date of RFC publication when published.
       (2) Please replace the date in the file name
         (ietf-system-capabilities@2021-04-02.yang)
         to the date of RFC publication.
       (3) Please replace the following reference
         with RFC number when published
         (i.e. RFC xxxx).";
      reference "RFC XXXX: YANG Modules describing Capabilities for Systems
       and Datastore Update Notifications";
   }
   container system-capabilities {
      config false;
      description "System capabilities.
       Capability values specified here at the system level
       are valid for all datastores and are used when the
       capability is not specified on the datastore level
       or for specific data nodes.";
      list datastore-capabilities {
         key datastore;
         description "Capabilities values per datastore.

         For non-NMDA servers/publishers 'config false' data is
         considered as if it was part of the running datastore.";
         leaf datastore {
            type leafref {
               path /yanglib:yang-library/yanglib:datastore/yanglib:name;
            }
            description "The datastore for which capabilities are defined.
           Only one specific datastore can be specified
           e.g., ds:conventional, which represents a set of
           configuration datastores, must not be used.";
         }
         list per-node-capabilities {
            description "Each list entry specifies capabilities for the selected
           data nodes. The same capabilities apply for the data nodes
           in the subtree below the selected nodes.

           The system SHALL order the entries according to their
           precedence. The order of the entries MUST NOT change unless
           the underlying capabilities also change.

           Note that the longest patch matching can be achieved
           by ordering more specific matches before less
           specific ones.";
            choice node-selection {
               description "A method to select some or all nodes within a datastore.";
               leaf node-selector {
                  type nacm:node-instance-identifier;
                  description "Selects the data nodes for which capabilities are
               specified. The special value '/' denotes all data nodes
               in the datastore, consistent with the path leaf node on
               page 41 [RFC8341].";
                  reference "RFC 8341: Network Configuration Access Control Model";
               }
            }
            leaf constrained {
               type empty;
               description "Indicates that 'where' filters and 'sort-by' parameters
         on the targeted 'config false' list node are constrained.
         If a list is not 'constrained', then full XPath 1.0
         expressions may be used in 'where' filters and all node
         identifiers are usable by 'sort-by'.";
            }
            leaf indexed {
               type empty;
               description "Indicates that the targeted descendent node of a
         'constrained' list (see the 'constrained' leaf) may be
         used in 'where' filters and/or 'sort-by' parameters.
         If a descendent node of a 'constrained' list is not
         'indexed', then it MUST NOT be used in 'where' filters
         or 'sort-by' parameters.";
            }
            leaf cursor-supported {
               type empty;
               description "Indicates that the targeted list node supports the
         'cursor' parameter.";
            }
         }
      }
   }
}
module ietf-netconf-acm {
   namespace urn:ietf:params:xml:ns:yang:ietf-netconf-acm;
   prefix nacm;
   import ietf-yang-types {
      prefix yang;
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
        WG List:  <mailto:netconf@ietf.org>

        Author:   Andy Bierman
                  <mailto:andy@yumaworks.com>

        Author:   Martin Bjorklund
                  <mailto:mbj@tail-f.com>";
   description "Network Configuration Access Control Model.

        Copyright (c) 2012 - 2018 IETF Trust and the persons
        identified as authors of the code.  All rights reserved.

        Redistribution and use in source and binary forms, with or
        without modification, is permitted pursuant to, and subject
        to the license terms contained in, the Simplified BSD
        License set forth in Section 4.c of the IETF Trust's
        Legal Provisions Relating to IETF Documents
        (https://trustee.ietf.org/license-info).

        This version of this YANG module is part of RFC 8341; see
        the RFC itself for full legal notices.";
   revision 2018-02-14 {
      description "Added support for YANG 1.1 actions and notifications tied to
          data nodes.  Clarified how NACM extensions can be used by
          other data models.";
      reference "RFC 8341: Network Configuration Access Control Model";
   }
   revision 2012-02-22 {
      description "Initial version.";
      reference "RFC 6536: Network Configuration Protocol (NETCONF)
                    Access Control Model";
   }
   extension default-deny-write {
      description "Used to indicate that the data model node
          represents a sensitive security system parameter.

          If present, the NETCONF server will only allow the designated
          'recovery session' to have write access to the node.  An
          explicit access control rule is required for all other users.

          If the NACM module is used, then it must be enabled (i.e.,
          /nacm/enable-nacm object equals 'true'), or this extension
          is ignored.

          The 'default-deny-write' extension MAY appear within a data
          definition statement.  It is ignored otherwise.";
   }
   extension default-deny-all {
      description "Used to indicate that the data model node
          controls a very sensitive security system parameter.

          If present, the NETCONF server will only allow the designated
          'recovery session' to have read, write, or execute access to
          the node.  An explicit access control rule is required for all
          other users.

          If the NACM module is used, then it must be enabled (i.e.,
          /nacm/enable-nacm object equals 'true'), or this extension
          is ignored.

          The 'default-deny-all' extension MAY appear within a data
          definition statement, 'rpc' statement, or 'notification'
          statement.  It is ignored otherwise.";
   }
   typedef user-name-type {
      type string {
         length 1..max;
      }
      description "General-purpose username string.";
   }
   typedef matchall-string-type {
      type string {
         pattern \*;
      }
      description "The string containing a single asterisk '*' is used
          to conceptually represent all possible values
          for the particular leaf using this data type.";
   }
   typedef access-operations-type {
      type bits {
         bit create {
            description "Any protocol operation that creates a
              new data node.";
         }
         bit read {
            description "Any protocol operation or notification that
              returns the value of a data node.";
         }
         bit update {
            description "Any protocol operation that alters an existing
              data node.";
         }
         bit delete {
            description "Any protocol operation that removes a data node.";
         }
         bit exec {
            description "Execution access to the specified protocol operation.";
         }
      }
      description "Access operation.";
   }
   typedef group-name-type {
      type string {
         length 1..max;
         pattern [^\*].*;
      }
      description "Name of administrative group to which
          users can be assigned.";
   }
   typedef action-type {
      type enumeration {
         enum permit {
            description "Requested action is permitted.";
         }
         enum deny {
            description "Requested action is denied.";
         }
      }
      description "Action taken by the server when a particular
          rule matches.";
   }
   typedef node-instance-identifier {
      type yang:xpath1.0;
      description "Path expression used to represent a special
          data node, action, or notification instance-identifier
          string.

          A node-instance-identifier value is an
          unrestricted YANG instance-identifier expression.

          All the same rules as an instance-identifier apply,
          except that predicates for keys are optional.  If a key
          predicate is missing, then the node-instance-identifier
          represents all possible server instances for that key.

          This XML Path Language (XPath) expression is evaluated in the
          following context:

             o  The set of namespace declarations are those in scope on
                the leaf element where this type is used.

             o  The set of variable bindings contains one variable,
                'USER', which contains the name of the user of the
                current session.

             o  The function library is the core function library, but
                note that due to the syntax restrictions of an
                instance-identifier, no functions are allowed.

             o  The context node is the root node in the data tree.

          The accessible tree includes actions and notifications tied
          to data nodes.";
   }
   container nacm {
      nacm:default-deny-all;
      description "Parameters for NETCONF access control model.";
      leaf enable-nacm {
         type boolean;
         default true;
         description "Enables or disables all NETCONF access control
            enforcement.  If 'true', then enforcement
            is enabled.  If 'false', then enforcement
            is disabled.";
      }
      leaf read-default {
         type action-type;
         default permit;
         description "Controls whether read access is granted if
            no appropriate rule is found for a
            particular read request.";
      }
      leaf write-default {
         type action-type;
         default deny;
         description "Controls whether create, update, or delete access
            is granted if no appropriate rule is found for a
            particular write request.";
      }
      leaf exec-default {
         type action-type;
         default permit;
         description "Controls whether exec access is granted if no appropriate
            rule is found for a particular protocol operation request.";
      }
      leaf enable-external-groups {
         type boolean;
         default true;
         description "Controls whether the server uses the groups reported by the
            NETCONF transport layer when it assigns the user to a set of
            NACM groups.  If this leaf has the value 'false', any group
            names reported by the transport layer are ignored by the
            server.";
      }
      leaf denied-operations {
         type yang:zero-based-counter32;
         config false;
         mandatory true;
         description "Number of times since the server last restarted that a
            protocol operation request was denied.";
      }
      leaf denied-data-writes {
         type yang:zero-based-counter32;
         config false;
         mandatory true;
         description "Number of times since the server last restarted that a
            protocol operation request to alter
            a configuration datastore was denied.";
      }
      leaf denied-notifications {
         type yang:zero-based-counter32;
         config false;
         mandatory true;
         description "Number of times since the server last restarted that
            a notification was dropped for a subscription because
            access to the event type was denied.";
      }
      container groups {
         description "NETCONF access control groups.";
         list group {
            key name;
            description "One NACM group entry.  This list will only contain
              configured entries, not any entries learned from
              any transport protocols.";
            leaf name {
               type group-name-type;
               description "Group name associated with this entry.";
            }
            leaf-list user-name {
               type user-name-type;
               description "Each entry identifies the username of
                a member of the group associated with
                this entry.";
            }
         }
      }
      list rule-list {
         key name;
         ordered-by user;
         description "An ordered collection of access control rules.";
         leaf name {
            type string {
               length 1..max;
            }
            description "Arbitrary name assigned to the rule-list.";
         }
         leaf-list group {
            type union {
               type matchall-string-type;
               type group-name-type;
            }
            description "List of administrative groups that will be
              assigned the associated access rights
              defined by the 'rule' list.

              The string '*' indicates that all groups apply to the
              entry.";
         }
         list rule {
            key name;
            ordered-by user;
            description "One access control rule.

              Rules are processed in user-defined order until a match is
              found.  A rule matches if 'module-name', 'rule-type', and
              'access-operations' match the request.  If a rule
              matches, the 'action' leaf determines whether or not
              access is granted.";
            leaf name {
               type string {
                  length 1..max;
               }
               description "Arbitrary name assigned to the rule.";
            }
            leaf module-name {
               type union {
                  type matchall-string-type;
                  type string;
               }
               default *;
               description "Name of the module associated with this rule.

                This leaf matches if it has the value '*' or if the
                object being accessed is defined in the module with the
                specified module name.";
            }
            choice rule-type {
               description "This choice matches if all leafs present in the rule
                match the request.  If no leafs are present, the
                choice matches all requests.";
               case protocol-operation {
                  leaf rpc-name {
                     type union {
                        type matchall-string-type;
                        type string;
                     }
                     description "This leaf matches if it has the value '*' or if
                    its value equals the requested protocol operation
                    name.";
                  }
               }
               case notification {
                  leaf notification-name {
                     type union {
                        type matchall-string-type;
                        type string;
                     }
                     description "This leaf matches if it has the value '*' or if its
                    value equals the requested notification name.";
                  }
               }
               case data-node {
                  leaf path {
                     type node-instance-identifier;
                     mandatory true;
                     description "Data node instance-identifier associated with the
                    data node, action, or notification controlled by
                    this rule.

                    Configuration data or state data
                    instance-identifiers start with a top-level
                    data node.  A complete instance-identifier is
                    required for this type of path value.

                    The special value '/' refers to all possible
                    datastore contents.";
                  }
               }
            }
            leaf access-operations {
               type union {
                  type matchall-string-type;
                  type access-operations-type;
               }
               default *;
               description "Access operations associated with this rule.

                This leaf matches if it has the value '*' or if the
                bit corresponding to the requested operation is set.";
            }
            leaf action {
               type action-type;
               mandatory true;
               description "The access control action associated with the
                rule.  If a rule has been determined to match a
                particular request, then this object is used
                to determine whether to permit or deny the
                request.";
            }
            leaf comment {
               type string;
               description "A textual description of the access rule.";
            }
         }
      }
   }
}
module ietf-yang-library {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-yang-library;
   prefix yanglib;
   import ietf-yang-types {
      prefix yang;
      reference "RFC 6991: Common YANG Data Types";
   }
   import ietf-inet-types {
      prefix inet;
      reference "RFC 6991: Common YANG Data Types";
   }
   import ietf-datastores {
      prefix ds;
      reference "RFC 8342: Network Management Datastore Architecture
                 (NMDA)";
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netconf/>
     WG List:  <mailto:netconf@ietf.org>

     Author:   Andy Bierman
               <mailto:andy@yumaworks.com>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Author:   Kent Watsen
               <mailto:kent+ietf@watsen.net>

     Author:   Robert Wilton
               <mailto:rwilton@cisco.com>";
   description "This module provides information about the YANG modules,
     datastores, and datastore schemas used by a network
     management server.
     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.

     Copyright (c) 2019 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8525; see
     the RFC itself for full legal notices.";
   revision 2019-01-04 {
      description "Added support for multiple datastores according to the
       Network Management Datastore Architecture (NMDA).";
      reference "RFC 8525: YANG Library";
   }
   revision 2016-04-09 {
      description "Initial revision.";
      reference "RFC 7895: YANG Module Library";
   }
   typedef revision-identifier {
      type string {
         pattern \d{4}-\d{2}-\d{2};
      }
      description "Represents a specific date in YYYY-MM-DD format.";
   }
   grouping module-identification-leafs {
      description "Parameters for identifying YANG modules and submodules.";
      leaf name {
         type yang:yang-identifier;
         mandatory true;
         description "The YANG module or submodule name.";
      }
      leaf revision {
         type revision-identifier;
         description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
      }
   }
   grouping location-leaf-list {
      description "Common leaf-list parameter for the locations of modules and
       submodules.";
      leaf-list location {
         type inet:uri;
         description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
      }
   }
   grouping module-implementation-parameters {
      description "Parameters for describing the implementation of a module.";
      leaf-list feature {
         type yang:yang-identifier;
         description "List of all YANG feature names from this module that are
         supported by the server, regardless whether they are defined
         in the module or any included submodule.";
      }
      leaf-list deviation {
         type leafref {
            path ../../module/name;
         }
         description "List of all YANG deviation modules used by this server to
         modify the conformance of the module associated with this
         entry.  Note that the same module can be used for deviations
         for multiple modules, so the same entry MAY appear within
         multiple 'module' entries.

         This reference MUST NOT (directly or indirectly)
         refer to the module being deviated.

         Robust clients may want to make sure that they handle a
         situation where a module deviates itself (directly or
         indirectly) gracefully.";
      }
   }
   grouping module-set-parameters {
      description "A set of parameters that describe a module set.";
      leaf name {
         type string;
         description "An arbitrary name of the module set.";
      }
      list module {
         key name;
         description "An entry in this list represents a module implemented by the
         server, as per Section 5.6.5 of RFC 7950, with a particular
         set of supported features and deviations.";
         reference "RFC 7950: The YANG 1.1 Data Modeling Language";
         uses module-identification-leafs;
         leaf name {
            type yang:yang-identifier;
            mandatory true;
            description "The YANG module or submodule name.";
         }
         leaf revision {
            type revision-identifier;
            description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
         }
         leaf namespace {
            type inet:uri;
            mandatory true;
            description "The XML namespace identifier for this module.";
         }
         uses location-leaf-list;
         leaf-list location {
            type inet:uri;
            description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
         }
         list submodule {
            key name;
            description "Each entry represents one submodule within the
           parent module.";
            uses module-identification-leafs;
            leaf name {
               type yang:yang-identifier;
               mandatory true;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type revision-identifier;
               description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
            }
            uses location-leaf-list;
            leaf-list location {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
            }
         }
         uses module-implementation-parameters;
         leaf-list feature {
            type yang:yang-identifier;
            description "List of all YANG feature names from this module that are
         supported by the server, regardless whether they are defined
         in the module or any included submodule.";
         }
         leaf-list deviation {
            type leafref {
               path ../../module/name;
            }
            description "List of all YANG deviation modules used by this server to
         modify the conformance of the module associated with this
         entry.  Note that the same module can be used for deviations
         for multiple modules, so the same entry MAY appear within
         multiple 'module' entries.

         This reference MUST NOT (directly or indirectly)
         refer to the module being deviated.

         Robust clients may want to make sure that they handle a
         situation where a module deviates itself (directly or
         indirectly) gracefully.";
         }
      }
      list import-only-module {
         key "name revision";
         description "An entry in this list indicates that the server imports
         reusable definitions from the specified revision of the
         module but does not implement any protocol-accessible
         objects from this revision.

         Multiple entries for the same module name MAY exist.  This
         can occur if multiple modules import the same module but
         specify different revision dates in the import statements.";
         leaf name {
            type yang:yang-identifier;
            description "The YANG module name.";
         }
         leaf revision {
            type union {
               type revision-identifier;
               type string {
                  length 0;
               }
            }
            description "The YANG module revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module.";
         }
         leaf namespace {
            type inet:uri;
            mandatory true;
            description "The XML namespace identifier for this module.";
         }
         uses location-leaf-list;
         leaf-list location {
            type inet:uri;
            description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
         }
         list submodule {
            key name;
            description "Each entry represents one submodule within the
           parent module.";
            uses module-identification-leafs;
            leaf name {
               type yang:yang-identifier;
               mandatory true;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type revision-identifier;
               description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
            }
            uses location-leaf-list;
            leaf-list location {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
            }
         }
      }
   }
   grouping yang-library-parameters {
      description "The YANG library data structure is represented as a grouping
       so it can be reused in configuration or another monitoring
       data structure.";
      list module-set {
         key name;
         description "A set of modules that may be used by one or more schemas.

         A module set does not have to be referentially complete,
         i.e., it may define modules that contain import statements
         for other modules not included in the module set.";
         uses module-set-parameters;
         leaf name {
            type string;
            description "An arbitrary name of the module set.";
         }
         list module {
            key name;
            description "An entry in this list represents a module implemented by the
         server, as per Section 5.6.5 of RFC 7950, with a particular
         set of supported features and deviations.";
            reference "RFC 7950: The YANG 1.1 Data Modeling Language";
            uses module-identification-leafs;
            leaf name {
               type yang:yang-identifier;
               mandatory true;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type revision-identifier;
               description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
            }
            leaf namespace {
               type inet:uri;
               mandatory true;
               description "The XML namespace identifier for this module.";
            }
            uses location-leaf-list;
            leaf-list location {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
            }
            list submodule {
               key name;
               description "Each entry represents one submodule within the
           parent module.";
               uses module-identification-leafs;
               leaf name {
                  type yang:yang-identifier;
                  mandatory true;
                  description "The YANG module or submodule name.";
               }
               leaf revision {
                  type revision-identifier;
                  description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
               }
               uses location-leaf-list;
               leaf-list location {
                  type inet:uri;
                  description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
               }
            }
            uses module-implementation-parameters;
            leaf-list feature {
               type yang:yang-identifier;
               description "List of all YANG feature names from this module that are
         supported by the server, regardless whether they are defined
         in the module or any included submodule.";
            }
            leaf-list deviation {
               type leafref {
                  path ../../module/name;
               }
               description "List of all YANG deviation modules used by this server to
         modify the conformance of the module associated with this
         entry.  Note that the same module can be used for deviations
         for multiple modules, so the same entry MAY appear within
         multiple 'module' entries.

         This reference MUST NOT (directly or indirectly)
         refer to the module being deviated.

         Robust clients may want to make sure that they handle a
         situation where a module deviates itself (directly or
         indirectly) gracefully.";
            }
         }
         list import-only-module {
            key "name revision";
            description "An entry in this list indicates that the server imports
         reusable definitions from the specified revision of the
         module but does not implement any protocol-accessible
         objects from this revision.

         Multiple entries for the same module name MAY exist.  This
         can occur if multiple modules import the same module but
         specify different revision dates in the import statements.";
            leaf name {
               type yang:yang-identifier;
               description "The YANG module name.";
            }
            leaf revision {
               type union {
                  type revision-identifier;
                  type string {
                     length 0;
                  }
               }
               description "The YANG module revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module.";
            }
            leaf namespace {
               type inet:uri;
               mandatory true;
               description "The XML namespace identifier for this module.";
            }
            uses location-leaf-list;
            leaf-list location {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
            }
            list submodule {
               key name;
               description "Each entry represents one submodule within the
           parent module.";
               uses module-identification-leafs;
               leaf name {
                  type yang:yang-identifier;
                  mandatory true;
                  description "The YANG module or submodule name.";
               }
               leaf revision {
                  type revision-identifier;
                  description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
               }
               uses location-leaf-list;
               leaf-list location {
                  type inet:uri;
                  description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
               }
            }
         }
      }
      list schema {
         key name;
         description "A datastore schema that may be used by one or more
         datastores.

         The schema must be valid and referentially complete, i.e.,
         it must contain modules to satisfy all used import
         statements for all modules specified in the schema.";
         leaf name {
            type string;
            description "An arbitrary name of the schema.";
         }
         leaf-list module-set {
            type leafref {
               path ../../module-set/name;
            }
            description "A set of module-sets that are included in this schema.
           If a non-import-only module appears in multiple module
           sets, then the module revision and the associated features
           and deviations must be identical.";
         }
      }
      list datastore {
         key name;
         description "A datastore supported by this server.

         Each datastore indicates which schema it supports.

         The server MUST instantiate one entry in this list per
         specific datastore it supports.
         Each datastore entry with the same datastore schema SHOULD
         reference the same schema.";
         leaf name {
            type ds:datastore-ref;
            description "The identity of the datastore.";
         }
         leaf schema {
            type leafref {
               path ../../schema/name;
            }
            mandatory true;
            description "A reference to the schema supported by this datastore.
           All non-import-only modules of the schema are implemented
           with their associated features and deviations.";
         }
      }
   }
   container yang-library {
      config false;
      description "Container holding the entire YANG library of this server.";
      uses yang-library-parameters;
      list module-set {
         key name;
         description "A set of modules that may be used by one or more schemas.

         A module set does not have to be referentially complete,
         i.e., it may define modules that contain import statements
         for other modules not included in the module set.";
         uses module-set-parameters;
         leaf name {
            type string;
            description "An arbitrary name of the module set.";
         }
         list module {
            key name;
            description "An entry in this list represents a module implemented by the
         server, as per Section 5.6.5 of RFC 7950, with a particular
         set of supported features and deviations.";
            reference "RFC 7950: The YANG 1.1 Data Modeling Language";
            uses module-identification-leafs;
            leaf name {
               type yang:yang-identifier;
               mandatory true;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type revision-identifier;
               description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
            }
            leaf namespace {
               type inet:uri;
               mandatory true;
               description "The XML namespace identifier for this module.";
            }
            uses location-leaf-list;
            leaf-list location {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
            }
            list submodule {
               key name;
               description "Each entry represents one submodule within the
           parent module.";
               uses module-identification-leafs;
               leaf name {
                  type yang:yang-identifier;
                  mandatory true;
                  description "The YANG module or submodule name.";
               }
               leaf revision {
                  type revision-identifier;
                  description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
               }
               uses location-leaf-list;
               leaf-list location {
                  type inet:uri;
                  description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
               }
            }
            uses module-implementation-parameters;
            leaf-list feature {
               type yang:yang-identifier;
               description "List of all YANG feature names from this module that are
         supported by the server, regardless whether they are defined
         in the module or any included submodule.";
            }
            leaf-list deviation {
               type leafref {
                  path ../../module/name;
               }
               description "List of all YANG deviation modules used by this server to
         modify the conformance of the module associated with this
         entry.  Note that the same module can be used for deviations
         for multiple modules, so the same entry MAY appear within
         multiple 'module' entries.

         This reference MUST NOT (directly or indirectly)
         refer to the module being deviated.

         Robust clients may want to make sure that they handle a
         situation where a module deviates itself (directly or
         indirectly) gracefully.";
            }
         }
         list import-only-module {
            key "name revision";
            description "An entry in this list indicates that the server imports
         reusable definitions from the specified revision of the
         module but does not implement any protocol-accessible
         objects from this revision.

         Multiple entries for the same module name MAY exist.  This
         can occur if multiple modules import the same module but
         specify different revision dates in the import statements.";
            leaf name {
               type yang:yang-identifier;
               description "The YANG module name.";
            }
            leaf revision {
               type union {
                  type revision-identifier;
                  type string {
                     length 0;
                  }
               }
               description "The YANG module revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module.";
            }
            leaf namespace {
               type inet:uri;
               mandatory true;
               description "The XML namespace identifier for this module.";
            }
            uses location-leaf-list;
            leaf-list location {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
            }
            list submodule {
               key name;
               description "Each entry represents one submodule within the
           parent module.";
               uses module-identification-leafs;
               leaf name {
                  type yang:yang-identifier;
                  mandatory true;
                  description "The YANG module or submodule name.";
               }
               leaf revision {
                  type revision-identifier;
                  description "The YANG module or submodule revision date.  If no revision
         statement is present in the YANG module or submodule, this
         leaf is not instantiated.";
               }
               uses location-leaf-list;
               leaf-list location {
                  type inet:uri;
                  description "Contains a URL that represents the YANG schema
         resource for this module or submodule.

         This leaf will only be present if there is a URL
         available for retrieval of the schema for this entry.";
               }
            }
         }
      }
      list schema {
         key name;
         description "A datastore schema that may be used by one or more
         datastores.

         The schema must be valid and referentially complete, i.e.,
         it must contain modules to satisfy all used import
         statements for all modules specified in the schema.";
         leaf name {
            type string;
            description "An arbitrary name of the schema.";
         }
         leaf-list module-set {
            type leafref {
               path ../../module-set/name;
            }
            description "A set of module-sets that are included in this schema.
           If a non-import-only module appears in multiple module
           sets, then the module revision and the associated features
           and deviations must be identical.";
         }
      }
      list datastore {
         key name;
         description "A datastore supported by this server.

         Each datastore indicates which schema it supports.

         The server MUST instantiate one entry in this list per
         specific datastore it supports.
         Each datastore entry with the same datastore schema SHOULD
         reference the same schema.";
         leaf name {
            type ds:datastore-ref;
            description "The identity of the datastore.";
         }
         leaf schema {
            type leafref {
               path ../../schema/name;
            }
            mandatory true;
            description "A reference to the schema supported by this datastore.
           All non-import-only modules of the schema are implemented
           with their associated features and deviations.";
         }
      }
      leaf content-id {
         type string;
         mandatory true;
         description "A server-generated identifier of the contents of the
         '/yang-library' tree.  The server MUST change the value of
         this leaf if the information represented by the
         '/yang-library' tree, except '/yang-library/content-id', has
         changed.";
      }
   }
   notification yang-library-update {
      description "Generated when any YANG library information on the
       server has changed.";
      leaf content-id {
         type leafref {
            path /yanglib:yang-library/yanglib:content-id;
         }
         mandatory true;
         description "Contains the YANG library content identifier for the updated
         YANG library at the time the notification is generated.";
      }
   }
   grouping module-list {
      status deprecated;
      description "The module data structure is represented as a grouping
       so it can be reused in configuration or another monitoring
       data structure.";
      grouping common-leafs {
         status deprecated;
         description "Common parameters for YANG modules and submodules.";
         leaf name {
            type yang:yang-identifier;
            status deprecated;
            description "The YANG module or submodule name.";
         }
         leaf revision {
            type union {
               type revision-identifier;
               type string {
                  length 0;
               }
            }
            status deprecated;
            description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
         }
      }
      grouping schema-leaf {
         status deprecated;
         description "Common schema leaf parameter for modules and submodules.";
         leaf schema {
            type inet:uri;
            description "Contains a URL that represents the YANG schema
           resource for this module or submodule.

           This leaf will only be present if there is a URL
           available for retrieval of the schema for this entry.";
         }
      }
      list module {
         key "name revision";
         status deprecated;
         description "Each entry represents one revision of one module
         currently supported by the server.";
         uses common-leafs {
            status deprecated;
         }
         leaf name {
            type yang:yang-identifier;
            status deprecated;
            description "The YANG module or submodule name.";
         }
         leaf revision {
            type union {
               type revision-identifier;
               type string {
                  length 0;
               }
            }
            status deprecated;
            description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
         }
         uses schema-leaf {
            status deprecated;
         }
         leaf schema {
            type inet:uri;
            description "Contains a URL that represents the YANG schema
           resource for this module or submodule.

           This leaf will only be present if there is a URL
           available for retrieval of the schema for this entry.";
         }
         leaf namespace {
            type inet:uri;
            mandatory true;
            status deprecated;
            description "The XML namespace identifier for this module.";
         }
         leaf-list feature {
            type yang:yang-identifier;
            status deprecated;
            description "List of YANG feature names from this module that are
           supported by the server, regardless of whether they are
           defined in the module or any included submodule.";
         }
         list deviation {
            key "name revision";
            status deprecated;
            description "List of YANG deviation module names and revisions
           used by this server to modify the conformance of
           the module associated with this entry.  Note that
           the same module can be used for deviations for
           multiple modules, so the same entry MAY appear
           within multiple 'module' entries.

           The deviation module MUST be present in the 'module'
           list, with the same name and revision values.
           The 'conformance-type' value will be 'implement' for
           the deviation module.";
            uses common-leafs {
               status deprecated;
            }
            leaf name {
               type yang:yang-identifier;
               status deprecated;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type union {
                  type revision-identifier;
                  type string {
                     length 0;
                  }
               }
               status deprecated;
               description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
            }
         }
         leaf conformance-type {
            type enumeration {
               enum implement {
                  description "Indicates that the server implements one or more
               protocol-accessible objects defined in the YANG module
               identified in this entry.  This includes deviation
               statements defined in the module.

               For YANG version 1.1 modules, there is at most one
               'module' entry with conformance type 'implement' for a
               particular module name, since YANG 1.1 requires that
               at most one revision of a module is implemented.

               For YANG version 1 modules, there SHOULD NOT be more
               than one 'module' entry for a particular module
               name.";
               }
               enum import {
                  description "Indicates that the server imports reusable definitions
               from the specified revision of the module but does
               not implement any protocol-accessible objects from
               this revision.

               Multiple 'module' entries for the same module name MAY
               exist.  This can occur if multiple modules import the
               same module but specify different revision dates in
               the import statements.";
               }
            }
            mandatory true;
            status deprecated;
            description "Indicates the type of conformance the server is claiming
           for the YANG module identified by this entry.";
         }
         list submodule {
            key "name revision";
            status deprecated;
            description "Each entry represents one submodule within the
           parent module.";
            uses common-leafs {
               status deprecated;
            }
            leaf name {
               type yang:yang-identifier;
               status deprecated;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type union {
                  type revision-identifier;
                  type string {
                     length 0;
                  }
               }
               status deprecated;
               description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
            }
            uses schema-leaf {
               status deprecated;
            }
            leaf schema {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
           resource for this module or submodule.

           This leaf will only be present if there is a URL
           available for retrieval of the schema for this entry.";
            }
         }
      }
   }
   container modules-state {
      config false;
      status deprecated;
      description "Contains YANG module monitoring information.";
      leaf module-set-id {
         type string;
         mandatory true;
         status deprecated;
         description "Contains a server-specific identifier representing
         the current set of modules and submodules.  The
         server MUST change the value of this leaf if the
         information represented by the 'module' list instances
         has changed.";
      }
      uses module-list {
         status deprecated;
      }
      list module {
         key "name revision";
         status deprecated;
         description "Each entry represents one revision of one module
         currently supported by the server.";
         uses common-leafs {
            status deprecated;
         }
         leaf name {
            type yang:yang-identifier;
            status deprecated;
            description "The YANG module or submodule name.";
         }
         leaf revision {
            type union {
               type revision-identifier;
               type string {
                  length 0;
               }
            }
            status deprecated;
            description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
         }
         uses schema-leaf {
            status deprecated;
         }
         leaf schema {
            type inet:uri;
            description "Contains a URL that represents the YANG schema
           resource for this module or submodule.

           This leaf will only be present if there is a URL
           available for retrieval of the schema for this entry.";
         }
         leaf namespace {
            type inet:uri;
            mandatory true;
            status deprecated;
            description "The XML namespace identifier for this module.";
         }
         leaf-list feature {
            type yang:yang-identifier;
            status deprecated;
            description "List of YANG feature names from this module that are
           supported by the server, regardless of whether they are
           defined in the module or any included submodule.";
         }
         list deviation {
            key "name revision";
            status deprecated;
            description "List of YANG deviation module names and revisions
           used by this server to modify the conformance of
           the module associated with this entry.  Note that
           the same module can be used for deviations for
           multiple modules, so the same entry MAY appear
           within multiple 'module' entries.

           The deviation module MUST be present in the 'module'
           list, with the same name and revision values.
           The 'conformance-type' value will be 'implement' for
           the deviation module.";
            uses common-leafs {
               status deprecated;
            }
            leaf name {
               type yang:yang-identifier;
               status deprecated;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type union {
                  type revision-identifier;
                  type string {
                     length 0;
                  }
               }
               status deprecated;
               description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
            }
         }
         leaf conformance-type {
            type enumeration {
               enum implement {
                  description "Indicates that the server implements one or more
               protocol-accessible objects defined in the YANG module
               identified in this entry.  This includes deviation
               statements defined in the module.

               For YANG version 1.1 modules, there is at most one
               'module' entry with conformance type 'implement' for a
               particular module name, since YANG 1.1 requires that
               at most one revision of a module is implemented.

               For YANG version 1 modules, there SHOULD NOT be more
               than one 'module' entry for a particular module
               name.";
               }
               enum import {
                  description "Indicates that the server imports reusable definitions
               from the specified revision of the module but does
               not implement any protocol-accessible objects from
               this revision.

               Multiple 'module' entries for the same module name MAY
               exist.  This can occur if multiple modules import the
               same module but specify different revision dates in
               the import statements.";
               }
            }
            mandatory true;
            status deprecated;
            description "Indicates the type of conformance the server is claiming
           for the YANG module identified by this entry.";
         }
         list submodule {
            key "name revision";
            status deprecated;
            description "Each entry represents one submodule within the
           parent module.";
            uses common-leafs {
               status deprecated;
            }
            leaf name {
               type yang:yang-identifier;
               status deprecated;
               description "The YANG module or submodule name.";
            }
            leaf revision {
               type union {
                  type revision-identifier;
                  type string {
                     length 0;
                  }
               }
               status deprecated;
               description "The YANG module or submodule revision date.
           A zero-length string is used if no revision statement
           is present in the YANG module or submodule.";
            }
            uses schema-leaf {
               status deprecated;
            }
            leaf schema {
               type inet:uri;
               description "Contains a URL that represents the YANG schema
           resource for this module or submodule.

           This leaf will only be present if there is a URL
           available for retrieval of the schema for this entry.";
            }
         }
      }
   }
   notification yang-library-change {
      status deprecated;
      description "Generated when the set of modules and submodules supported
       by the server has changed.";
      leaf module-set-id {
         type leafref {
            path /yanglib:modules-state/yanglib:module-set-id;
         }
         mandatory true;
         status deprecated;
         description "Contains the module-set-id value representing the
         set of modules and submodules supported at the server
         at the time the notification is generated.";
      }
   }
}
module ietf-list-pagination-nc {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-list-pagination-nc;
   prefix lpgnc;
   import ietf-netconf {
      prefix nc;
      reference "RFC 6241: Network Configuration Protocol (NETCONF)";
   }
   import ietf-netconf-nmda {
      prefix ncds;
      reference "RFC 8526: NETCONF Extensions to Support the
                 Network Management Datastore Architecture";
   }
   import ietf-list-pagination {
      prefix lpg;
      reference "RFC XXXX: List Pagination for YANG-driven Protocols";
   }
   organization "IETF NETCONF (Network Configuration) Working Group";
   contact "WG Web:   https://datatracker.ietf.org/wg/netconf
       WG List:  NETCONF WG list <mailto:netconf@ietf.org>";
   description "This module augments the <get>, <get-config>, and <get-data>
     'rpc' statements to support list pagination.

     Copyright (c) 2024 IETF Trust and the persons identified
     as authors of the code. All rights reserved.

     Redistribution and use in source and binary forms, with
     or without modification, is permitted pursuant to, and
     subject to the license terms contained in, the Revised
     BSD License set forth in Section 4.c of the IETF Trust's
     Legal Provisions Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC XXXX
     (https://www.rfc-editor.org/info/rfcXXXX); see the RFC
     itself for full legal notices.

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL',
     'SHALL NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED',
     'NOT RECOMMENDED', 'MAY', and 'OPTIONAL' in this document
     are to be interpreted as described in BCP 14 (RFC 2119)
     (RFC 8174) when, and only when, they appear in all
     capitals, as shown here.";
   revision 2024-10-21 {
      description "Initial revision.";
      reference "RFC XXXX: NETCONF Extensions to Support List Pagination";
   }
   grouping pagination-parameters {
      description "A grouping for list pagination parameters.";
      container list-pagination {
         description "List pagination parameters.";
         uses lpg:where-param-grouping;
         leaf where {
            type union {
               type yang:xpath1.0;
               type enumeration {
                  enum unfiltered {
                     description "Indicates that no entries are to be filtered
               from the working result-set.";
                  }
               }
            }
            default unfiltered;
            description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
         }
         uses lpg:sort-by-param-grouping;
         leaf sort-by {
            type union {
               type string {
                  pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
               }
               type enumeration {
                  enum none {
                     description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                  }
               }
            }
            default none;
            description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
         }
         uses lpg:locale-param-grouping;
         leaf locale {
            type string;
            description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
         }
         uses lpg:direction-param-grouping;
         leaf direction {
            type enumeration {
               enum forwards {
                  description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
               }
               enum backwards {
                  description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
               }
            }
            default forwards;
            description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
         }
         uses lpg:cursor-param-grouping;
         leaf cursor {
            type string;
            description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
         }
         uses lpg:offset-param-grouping;
         leaf offset {
            type uint32;
            default 0;
            description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
         }
         uses lpg:limit-param-grouping;
         leaf limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
         }
         uses lpg:sublist-limit-param-grouping;
         leaf sublist-limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
         }
      }
   }
   augment /nc:get/nc:input {
      description "Allow the 'get' operation to use content filter
       parameter for specifying the YANG list or leaf-list
       that is to be retrieved";
      uses pagination-parameters;
      container list-pagination {
         description "List pagination parameters.";
         uses lpg:where-param-grouping;
         leaf where {
            type union {
               type yang:xpath1.0;
               type enumeration {
                  enum unfiltered {
                     description "Indicates that no entries are to be filtered
               from the working result-set.";
                  }
               }
            }
            default unfiltered;
            description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
         }
         uses lpg:sort-by-param-grouping;
         leaf sort-by {
            type union {
               type string {
                  pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
               }
               type enumeration {
                  enum none {
                     description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                  }
               }
            }
            default none;
            description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
         }
         uses lpg:locale-param-grouping;
         leaf locale {
            type string;
            description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
         }
         uses lpg:direction-param-grouping;
         leaf direction {
            type enumeration {
               enum forwards {
                  description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
               }
               enum backwards {
                  description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
               }
            }
            default forwards;
            description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
         }
         uses lpg:cursor-param-grouping;
         leaf cursor {
            type string;
            description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
         }
         uses lpg:offset-param-grouping;
         leaf offset {
            type uint32;
            default 0;
            description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
         }
         uses lpg:limit-param-grouping;
         leaf limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
         }
         uses lpg:sublist-limit-param-grouping;
         leaf sublist-limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
         }
      }
   }
   augment /nc:get-config/nc:input {
      description "Allow the 'get-config' operation to use content filter
       parameter for specifying the YANG list or leaf-list
       that is to be retrieved";
      uses pagination-parameters;
      container list-pagination {
         description "List pagination parameters.";
         uses lpg:where-param-grouping;
         leaf where {
            type union {
               type yang:xpath1.0;
               type enumeration {
                  enum unfiltered {
                     description "Indicates that no entries are to be filtered
               from the working result-set.";
                  }
               }
            }
            default unfiltered;
            description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
         }
         uses lpg:sort-by-param-grouping;
         leaf sort-by {
            type union {
               type string {
                  pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
               }
               type enumeration {
                  enum none {
                     description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                  }
               }
            }
            default none;
            description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
         }
         uses lpg:locale-param-grouping;
         leaf locale {
            type string;
            description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
         }
         uses lpg:direction-param-grouping;
         leaf direction {
            type enumeration {
               enum forwards {
                  description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
               }
               enum backwards {
                  description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
               }
            }
            default forwards;
            description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
         }
         uses lpg:cursor-param-grouping;
         leaf cursor {
            type string;
            description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
         }
         uses lpg:offset-param-grouping;
         leaf offset {
            type uint32;
            default 0;
            description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
         }
         uses lpg:limit-param-grouping;
         leaf limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
         }
         uses lpg:sublist-limit-param-grouping;
         leaf sublist-limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
         }
      }
   }
   augment /ncds:get-data/ncds:input {
      description "Allow the 'get-data' operation to use content filter
       parameter for specifying the YANG list or leaf-list
       that is to be retrieved";
      uses pagination-parameters;
      container list-pagination {
         description "List pagination parameters.";
         uses lpg:where-param-grouping;
         leaf where {
            type union {
               type yang:xpath1.0;
               type enumeration {
                  enum unfiltered {
                     description "Indicates that no entries are to be filtered
               from the working result-set.";
                  }
               }
            }
            default unfiltered;
            description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
         }
         uses lpg:sort-by-param-grouping;
         leaf sort-by {
            type union {
               type string {
                  pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
               }
               type enumeration {
                  enum none {
                     description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                  }
               }
            }
            default none;
            description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
         }
         uses lpg:locale-param-grouping;
         leaf locale {
            type string;
            description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
         }
         uses lpg:direction-param-grouping;
         leaf direction {
            type enumeration {
               enum forwards {
                  description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
               }
               enum backwards {
                  description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
               }
            }
            default forwards;
            description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
         }
         uses lpg:cursor-param-grouping;
         leaf cursor {
            type string;
            description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
         }
         uses lpg:offset-param-grouping;
         leaf offset {
            type uint32;
            default 0;
            description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
         }
         uses lpg:limit-param-grouping;
         leaf limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
         }
         uses lpg:sublist-limit-param-grouping;
         leaf sublist-limit {
            type union {
               type uint32 {
                  range 1..max;
               }
               type enumeration {
                  enum unbounded {
                     description "Indicates that the number of entries that may be
               returned is unbounded.";
                  }
               }
            }
            default unbounded;
            description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
         }
      }
   }
}
module ietf-netconf-nmda {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-netconf-nmda;
   prefix ncds;
   import ietf-yang-types {
      prefix yang;
      reference "RFC 6991: Common YANG Data Types";
   }
   import ietf-inet-types {
      prefix inet;
      reference "RFC 6991: Common YANG Data Types";
   }
   import ietf-datastores {
      prefix ds;
      reference "RFC 8342: Network Management Datastore Architecture
                 (NMDA)";
   }
   import ietf-origin {
      prefix or;
      reference "RFC 8342: Network Management Datastore Architecture
                 (NMDA)";
   }
   import ietf-netconf {
      prefix nc;
      reference "RFC 6241: Network Configuration Protocol (NETCONF)";
   }
   import ietf-netconf-with-defaults {
      prefix ncwd;
      reference "RFC 6243: With-defaults Capability for NETCONF";
   }
   organization "IETF NETCONF Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netconf/>

     WG List:  <mailto:netconf@ietf.org>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Author:   Phil Shafer
               <mailto:phil@juniper.net>

     Author:   Kent Watsen
               <mailto:kent+ietf@watsen.net>

     Author:   Robert Wilton
               <mailto:rwilton@cisco.com>";
   description "This YANG module defines a set of NETCONF operations to support
     the Network Management Datastore Architecture (NMDA).

     The key words 'MUST', 'MUST NOT', 'REQUIRED', 'SHALL', 'SHALL
     NOT', 'SHOULD', 'SHOULD NOT', 'RECOMMENDED', 'NOT RECOMMENDED',
     'MAY', and 'OPTIONAL' in this document are to be interpreted as
     described in BCP 14 (RFC 2119) (RFC 8174) when, and only when,
     they appear in all capitals, as shown here.

     Copyright (c) 2019 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8526; see
     the RFC itself for full legal notices.";
   revision 2019-01-07 {
      description "Initial revision.";
      reference "RFC 8526: NETCONF Extensions to Support the Network Management
                 Datastore Architecture";
   }
   feature origin {
      description "Indicates that the server supports the 'origin' annotation.";
      reference "RFC 8342: Network Management Datastore Architecture (NMDA)";
   }
   feature with-defaults {
      description "NETCONF :with-defaults capability.  If the server advertises
       the :with-defaults capability for a session, then this
       feature must also be enabled for that session.  Otherwise,
       this feature must not be enabled.";
      reference "RFC 6243: With-defaults Capability for NETCONF, Section 4; and
       RFC 8526: NETCONF Extensions to Support the Network Management
                 Datastore Architecture, Section 3.1.1.2";
   }
   rpc get-data {
      description "Retrieve data from an NMDA datastore.  The content returned
       by get-data must satisfy all filters, i.e., the filter
       criteria are logically ANDed.

       Any ancestor nodes (including list keys) of nodes selected by
       the filters are included in the response.

       The 'with-origin' parameter is only valid for an operational
       datastore.  If 'with-origin' is used with an invalid
       datastore, then the server MUST return an <rpc-error> element
       with an <error-tag> value of 'invalid-value'.

       The 'with-defaults' parameter only applies to the operational
       datastore if the NETCONF :with-defaults and
       :with-operational-defaults capabilities are both advertised.
       If the 'with-defaults' parameter is present in a request for
       which it is not supported, then the server MUST return an
       <rpc-error> element with an <error-tag> value of
       'invalid-value'.";
      input {
         leaf datastore {
            type ds:datastore-ref;
            mandatory true;
            description "Datastore from which to retrieve data.

           If the datastore is not supported by the server, then the
           server MUST return an <rpc-error> element with an
           <error-tag> value of 'invalid-value'.";
         }
         choice filter-spec {
            description "The content filter specification for this request.";
            anydata subtree-filter {
               description "This parameter identifies the portions of the
             target datastore to retrieve.";
               reference "RFC 6241: Network Configuration Protocol (NETCONF),
                       Section 6";
            }
            leaf xpath-filter {
               if-feature nc:xpath;
               type yang:xpath1.0;
               description "This parameter contains an XPath expression identifying
             the portions of the target datastore to retrieve.

             If the expression returns a node-set, all nodes in the
             node-set are selected by the filter.  Otherwise, if the
             expression does not return a node-set, then the
             <get-data> operation fails.

             The expression is evaluated in the following XPath
             context:

               o  The set of namespace declarations are those in
                  scope on the 'xpath-filter' leaf element.

               o  The set of variable bindings is empty.

               o  The function library is the core function library,
                  and the XPath functions are defined in Section 10
                  of RFC 7950.

               o  The context node is the root node of the target
                  datastore.";
            }
         }
         leaf config-filter {
            type boolean;
            description "Filter for nodes with the given value for their 'config'
           property.  When this leaf is set to 'true', only 'config
           true' nodes are selected, and when set to 'false', only
           'config false' nodes are selected.  If this leaf is not
           present, no nodes are filtered.";
         }
         leaf max-depth {
            type union {
               type uint16 {
                  range 1..65535;
               }
               type enumeration {
                  enum unbounded {
                     description "All descendant nodes are included.";
                  }
               }
            }
            default unbounded;
            description "For each node selected by the filters, this parameter
           selects how many conceptual subtree levels should be
           returned in the reply.  If the depth is 1, the reply
           includes just the selected nodes but no children.  If the
           depth is 'unbounded', all descendant nodes are included.";
         }
         container list-pagination {
            description "List pagination parameters.";
            uses lpg:where-param-grouping;
            leaf where {
               type union {
                  type yang:xpath1.0;
                  type enumeration {
                     enum unfiltered {
                        description "Indicates that no entries are to be filtered
               from the working result-set.";
                     }
                  }
               }
               default unfiltered;
               description "The 'where' parameter specifies a boolean expression
         that result-set entries must match.

         It is an error if the XPath expression references a node
         identifier that does not exist in the schema, is optional
         or conditional in the schema or, for constrained 'config
         false' lists and leaf-lists, if the node identifier does
         not point to a node having the 'indexed' extension
         statement applied to it (see RFC XXXX).";
            }
            uses lpg:sort-by-param-grouping;
            leaf sort-by {
               type union {
                  type string {
                     pattern ([0-9a-zA-z._-]*:)?[0-9a-zA-Z._-]*(/([0-9a-zA-Z._-]*:)?[0-9a-zA-Z._-]*)*;
                  }
                  type enumeration {
                     enum none {
                        description "Indicates that the list or leaf-list's default
               order is to be used, per the YANG 'ordered-by'
               statement.";
                     }
                  }
               }
               default none;
               description "The 'sort-by' parameter indicates the node in the
         working result-set (i.e., after the 'where' parameter
         has been applied) that entries should be sorted by.

         Sorts are in ascending order (e.g., '1' before '9',
         'a' before 'z', etc.).  Missing values are sorted to
         the end (e.g., after all nodes having values).";
            }
            uses lpg:locale-param-grouping;
            leaf locale {
               type string;
               description "The 'locale' parameter indicates the locale which the
         entries in the working result-set should be collated.";
            }
            uses lpg:direction-param-grouping;
            leaf direction {
               type enumeration {
                  enum forwards {
                     description "Indicates that entries should be traversed from
              the first to last item in the working result set.";
                  }
                  enum backwards {
                     description "Indicates that entries should be traversed from
              the last to first item in the working result set.";
                  }
               }
               default forwards;
               description "The 'direction' parameter indicates how the entries in the
         working result-set (i.e., after the 'sort-by' parameter
         has been applied) should be traversed.";
            }
            uses lpg:cursor-param-grouping;
            leaf cursor {
               type string;
               description "The 'cursor' parameter indicates where to start the working
         result-set (i.e. after the 'direction' parameter has been
         applied), the elements before the cursor are skipped over
         when preparing the response. Furthermare the result-set is
         annotated with attributes for the next and previous cursors
         following a result-set constrained with the 'limit' query
         parameter.";
            }
            uses lpg:offset-param-grouping;
            leaf offset {
               type uint32;
               default 0;
               description "The 'offset' parameter indicates the number of entries
         in the working result-set (i.e., after the 'direction'
         parameter has been applied) that should be skipped over
         when preparing the response.";
            }
            uses lpg:limit-param-grouping;
            leaf limit {
               type union {
                  type uint32 {
                     range 1..max;
                  }
                  type enumeration {
                     enum unbounded {
                        description "Indicates that the number of entries that may be
               returned is unbounded.";
                     }
                  }
               }
               default unbounded;
               description "The 'limit' parameter limits the number of entries returned
         from the working result-set (i.e., after the 'offset'
         parameter has been applied).

         Any result-set that is limited includes, somewhere in its
         encoding, the metadata value 'remaining' to indicate the
         number entries not included in the result set.";
            }
            uses lpg:sublist-limit-param-grouping;
            leaf sublist-limit {
               type union {
                  type uint32 {
                     range 1..max;
                  }
                  type enumeration {
                     enum unbounded {
                        description "Indicates that the number of entries that may be
               returned is unbounded.";
                     }
                  }
               }
               default unbounded;
               description "The 'sublist-limit' parameter limits the number of entries
         for descendent lists and leaf-lists.

         Any result-set that is limited includes, somewhere in
         its encoding, the metadata value 'remaining' to indicate
         the number entries not included in the result set.";
            }
         }
      }
      output {
         anydata data {
            description "Copy of the source datastore subset that matched
           the filter criteria (if any).  An empty data
           container indicates that the request did not
           produce any results.";
         }
      }
   }
   rpc edit-data {
      description "Edit data in an NMDA datastore.

       If an error condition occurs such that an error severity
       <rpc-error> element is generated, the server will stop
       processing the <edit-data> operation and restore the
       specified configuration to its complete state at
       the start of this <edit-data> operation.";
      input {
         leaf datastore {
            type ds:datastore-ref;
            mandatory true;
            description "Datastore that is the target of the <edit-data> operation.

           If the target datastore is not writable, or is not
           supported by the server, then the server MUST return an
           <rpc-error> element with an <error-tag> value of
           'invalid-value'.";
         }
         leaf default-operation {
            type enumeration {
               enum merge {
                  description "The default operation is merge.";
               }
               enum replace {
                  description "The default operation is replace.";
               }
               enum none {
                  description "There is no default operation.";
               }
            }
            default merge;
            description "The default operation to use.";
         }
         choice edit-content {
            mandatory true;
            description "The content for the edit operation.";
            anydata config {
               description "Inline config content.";
            }
         }
      }
   }
   augment /nc:lock/nc:input/nc:target/nc:config-target {
      description "Add NMDA datastore as target.";
      leaf datastore {
         type ds:datastore-ref;
         description "Datastore to lock.

         The <lock> operation is only supported on writable
         datastores.

         If the <lock> operation is not supported by the server on
         the specified target datastore, then the server MUST return
         an <rpc-error> element with an <error-tag> value of
         'invalid-value'.";
      }
   }
   augment /nc:unlock/nc:input/nc:target/nc:config-target {
      description "Add NMDA datastore as target.";
      leaf datastore {
         type ds:datastore-ref;
         description "Datastore to unlock.

         The <unlock> operation is only supported on writable
         datastores.

         If the <unlock> operation is not supported by the server on
         the specified target datastore, then the server MUST return
         an <rpc-error> element with an <error-tag> value of
         'invalid-value'.";
      }
   }
   augment /nc:validate/nc:input/nc:source/nc:config-source {
      description "Add NMDA datastore as source.";
      leaf datastore {
         type ds:datastore-ref;
         description "Datastore to validate.

         The <validate> operation is supported only on configuration
         datastores.

         If the <validate> operation is not supported by the server
         on the specified target datastore, then the server MUST
         return an <rpc-error> element with an <error-tag> value of
         'invalid-value'.";
      }
   }
}
module ietf-origin {
   yang-version 1.1;
   namespace urn:ietf:params:xml:ns:yang:ietf-origin;
   prefix or;
   import ietf-yang-metadata {
      prefix md;
   }
   organization "IETF Network Modeling (NETMOD) Working Group";
   contact "WG Web:   <https://datatracker.ietf.org/wg/netmod/>

     WG List:  <mailto:netmod@ietf.org>

     Author:   Martin Bjorklund
               <mailto:mbj@tail-f.com>

     Author:   Juergen Schoenwaelder
               <mailto:j.schoenwaelder@jacobs-university.de>

     Author:   Phil Shafer
               <mailto:phil@juniper.net>

     Author:   Kent Watsen
               <mailto:kwatsen@juniper.net>

     Author:   Rob Wilton
               <rwilton@cisco.com>";
   description "This YANG module defines an 'origin' metadata annotation and a
     set of identities for the origin value.

     Copyright (c) 2018 IETF Trust and the persons identified as
     authors of the code.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject to
     the license terms contained in, the Simplified BSD License set
     forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (https://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 8342
     (https://www.rfc-editor.org/info/rfc8342); see the RFC itself
     for full legal notices.";
   revision 2018-02-14 {
      description "Initial revision.";
      reference "RFC 8342: Network Management Datastore Architecture (NMDA)";
   }
   identity origin {
      description "Abstract base identity for the origin annotation.";
   }
   identity intended {
      base origin;
      description "Denotes configuration from the intended configuration
       datastore.";
   }
   identity dynamic {
      base origin;
      description "Denotes configuration from a dynamic configuration
       datastore.";
   }
   identity system {
      base origin;
      description "Denotes configuration originated by the system itself.

       Examples of system configuration include applied configuration
       for an always-existing loopback interface, or interface
       configuration that is auto-created due to the hardware
       currently present in the device.";
   }
   identity learned {
      base origin;
      description "Denotes configuration learned from protocol interactions with
       other devices, instead of via either the intended
       configuration datastore or any dynamic configuration
       datastore.

       Examples of protocols that provide learned configuration
       include link-layer negotiations, routing protocols, and
       DHCP.";
   }
   identity default {
      base origin;
      description "Denotes configuration that does not have a configured or
       learned value but has a default value in use.  Covers both
       values defined in a 'default' statement and values defined
       via an explanation in a 'description' statement.";
   }
   identity unknown {
      base origin;
      description "Denotes configuration for which the system cannot identify the
       origin.";
   }
   typedef origin-ref {
      type identityref {
         base origin;
      }
      description "An origin identity reference.";
   }
   md:annotation {
      type origin-ref;
      description "The 'origin' annotation can be present on any configuration
       data node in the operational state datastore.  It specifies
       from where the node originated.  If not specified for a given
       configuration data node, then the origin is the same as the
       origin of its parent node in the data tree.  The origin for
       any top-level configuration data nodes must be specified.";
   }
}
module ietf-netconf-with-defaults {
   namespace urn:ietf:params:xml:ns:yang:ietf-netconf-with-defaults;
   prefix ncwd;
   import ietf-netconf {
      prefix nc;
   }
   organization "IETF NETCONF (Network Configuration Protocol) Working Group";
   contact "WG Web:   <http://tools.ietf.org/wg/netconf/>

     WG List:  <netconf@ietf.org>

     WG Chair: Bert Wijnen
               <bertietf@bwijnen.net>

     WG Chair: Mehmet Ersue
               <mehmet.ersue@nsn.com>

     Editor: Andy Bierman
             <andy.bierman@brocade.com>

     Editor: Balazs Lengyel
             <balazs.lengyel@ericsson.com>";
   description "This module defines an extension to the NETCONF protocol
     that allows the NETCONF client to control how default
     values are handled by the server in particular NETCONF
     operations.

     Copyright (c) 2011 IETF Trust and the persons identified as
     the document authors.  All rights reserved.

     Redistribution and use in source and binary forms, with or
     without modification, is permitted pursuant to, and subject
     to the license terms contained in, the Simplified BSD License
     set forth in Section 4.c of the IETF Trust's Legal Provisions
     Relating to IETF Documents
     (http://trustee.ietf.org/license-info).

     This version of this YANG module is part of RFC 6243; see
     the RFC itself for full legal notices.";
   revision 2011-06-01 {
      description "Initial version.";
      reference "RFC 6243: With-defaults Capability for NETCONF";
   }
   typedef with-defaults-mode {
      description "Possible modes to report default data.";
      reference "RFC 6243; Section 3.";
      type enumeration {
         enum report-all {
            description "All default data is reported.";
            reference "RFC 6243; Section 3.1";
         }
         enum report-all-tagged {
            description "All default data is reported.
                Any nodes considered to be default data
                will contain a 'default' XML attribute,
                set to 'true' or '1'.";
            reference "RFC 6243; Section 3.4";
         }
         enum trim {
            description "Values are not reported if they contain the default.";
            reference "RFC 6243; Section 3.2";
         }
         enum explicit {
            description "Report values that contain the definition of
                explicitly set data.";
            reference "RFC 6243; Section 3.3";
         }
      }
   }
   grouping with-defaults-parameters {
      description "Contains the <with-defaults> parameter for control
        of defaults in NETCONF retrieval operations.";
      leaf with-defaults {
         description "The explicit defaults processing mode requested.";
         reference "RFC 6243; Section 4.5.1";
         type with-defaults-mode;
      }
   }
   augment /nc:get-config/nc:input {
      description "Adds the <with-defaults> parameter to the
          input of the NETCONF <get-config> operation.";
      reference "RFC 6243; Section 4.5.1";
      uses with-defaults-parameters;
      leaf with-defaults {
         description "The explicit defaults processing mode requested.";
         reference "RFC 6243; Section 4.5.1";
         type with-defaults-mode;
      }
   }
   augment /nc:get/nc:input {
      description "Adds the <with-defaults> parameter to
          the input of the NETCONF <get> operation.";
      reference "RFC 6243; Section 4.5.1";
      uses with-defaults-parameters;
      leaf with-defaults {
         description "The explicit defaults processing mode requested.";
         reference "RFC 6243; Section 4.5.1";
         type with-defaults-mode;
      }
   }
   augment /nc:copy-config/nc:input {
      description "Adds the <with-defaults> parameter to
          the input of the NETCONF <copy-config> operation.";
      reference "RFC 6243; Section 4.5.1";
      uses with-defaults-parameters;
      leaf with-defaults {
         description "The explicit defaults processing mode requested.";
         reference "RFC 6243; Section 4.5.1";
         type with-defaults-mode;
      }
   }
}
